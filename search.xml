<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[VXL库的简单使用]]></title>
    <url>%2F2017%2F11%2F07%2FVXL%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[VXL库该库是进行矩阵运算的一个矩阵库，个人感觉使用起来跟eigen库还是比较像，毕竟都是基于C++编写的矩阵运算库。 资源该库是ITK这个开源项目中的数学计算部分，ITK是一个开源的跨平台的图像分析算法研究平台。感觉国内使用的人好像并不是很多，所以之前找到的资料也比较少，下面是自己找到的资源的链接： http://xueshu.baidu.com/s?wd=%E5%9F%BA%E4%BA%8EITK%E6%95%B0%E5%AD%A6%E5%BA%93%E7%9A%84%E7%9F%A9%E9%98%B5%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97&amp;rsv_bp=0&amp;tn=SE_baiduxueshu_c1gjeupa&amp;rsv_spt=3&amp;ie=utf-8&amp;f=8&amp;rsv_sug2=1&amp;sc_f_para=sc_tasktype%3D%7BfirstSimpleSearch%7D&amp;rsv_n=2 https://public.kitware.com/vxl/doc/release/ VXL库的下载我使用的是vxl-1.17.0可以直接百度下载： https://zh.osdn.net/projects/sfnet_vxl/downloads/vxl/1.17b/vxl-1.17.0-b.tar.gz/ 或者可以在我的github上进行下载： https://github.com/huanghailiang/vxl-1.17.0.git VXL库的简单使用在上面资源的链接中都有讲vxl这个库的使用，尤其VXL Documentation中更加全面。 下面是自己给的一些最常用到的一些简单的例子，如果后面有时间有兴趣的话会接着更新，如果没有就….. 编写CMakeList.txt来进行链接库生成工程，省去自己链接库的麻烦： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#=========================================================================# $Author$# $Date$# $Revision$#=========================================================================CMAKE_MINIMUM_REQUIRED(VERSION 2.4)IF(COMMAND cmake_policy) cmake_policy(SET CMP0003 NEW)ENDIF(COMMAND cmake_policy)PROJECT(VNL)FIND_PACKAGE(VXL) IF(VXL_FOUND) INCLUDE($&#123;VXL_CMAKE_DIR&#125;/UseVXL.cmake)ENDIF(VXL_FOUND)IF(WIN32)ADD_DEFINITIONS(-D_ALLOW_KEYWORD_MACROS)ENDIF(WIN32)#IF( VXL_VNL_FOUND ) INCLUDE_DIRECTORIES( $&#123;VXL_VNL_INCLUDE_DIR&#125; ) SET(IO_API_SRCS common.cpp ) file(GLOB_RECURSE IO_API_HDRS common.h ) ADD_LIBRARY(io_api $&#123;API_LIBRARY_TYPE&#125; $&#123;IO_API_SRCS&#125; $&#123;IO_API_HDRS&#125;)SET( VNL $&#123;VNL&#125; vnl_example.cpp )ADD_EXECUTABLE( VNL $&#123;VNL&#125;)TARGET_LINK_LIBRARIES( VNL io_api vnl_algo vnl vcl netlib) 自己照着编写的一些简单的使用例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/**************************************************///该程序主要是为了学习使用VXL这个库而制作的//数字vnl库旨在为数字编程提供一个环境，结合了Mathematica和Matlab等软件的易用性，C的速度和C++的优雅。/**************************************************//*************************************************///矩阵的模板类/*************************************************/#include &lt;vnl/vnl_matrix.h&gt;#include &lt;vcl_iostream.h&gt;int main()&#123; //定义一个矩阵A而不给它设定大小 vnl_matrix&lt;double&gt; A; printf("A_rows=%d \t A_cols=%d\n", A.rows(), A.cols()); //定义一个矩阵B设定大小为3*5的矩阵,但是不给初值 vnl_matrix&lt;double&gt; B(3, 5); printf("B_rows=%d \t B_cols=%d\n", B.rows(), B.cols()); //定义一个矩阵C设定大小为3*5的矩阵，并且给任意的初值，这里设置初值为1 vnl_matrix&lt;double&gt; C(3, 5, 1); printf("C_rows=%d \t C_cols=%d\n", C.rows(), C.cols()); //矩阵输出，这个格式跟C++很像，不过需要包含 vcl_iostream.h 这个头文件 vcl_cerr &lt;&lt;" C 初值为1"&lt;&lt; vcl_endl; printf("C_rows=%d \t C_cols=%d\n", C.rows(), C.cols()); vcl_cerr &lt;&lt; C &lt;&lt; vcl_endl; //定义一个矩证D，初值为0 vnl_matrix&lt;double&gt; D(3, 3, vnl_matrix_null); vcl_cerr &lt;&lt;" D 初值为0 vnl_matrix_null"&lt;&lt; vcl_endl; printf("D_rows=%d \t D_cols=%d\n", D.rows(), D.cols()); vcl_cerr &lt;&lt; D &lt;&lt; vcl_endl; //单位矩阵 //定义一个 单位矩证 E ，单位矩阵的话，矩阵的长宽一定是一样大的 vnl_matrix&lt;double&gt; E(3, 3, vnl_matrix_identity); vcl_cerr &lt;&lt;" E 单位阵 vnl_matrix_identity"&lt;&lt; vcl_endl; printf("E_rows=%d \t E_cols=%d\n", E.rows(), E.cols()); vcl_cerr &lt;&lt; E &lt;&lt; vcl_endl; //矩阵的前n位(第三个参数)自动被数组赋值，其他位不变，行优先 double f[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 &#125;; vnl_matrix&lt;double&gt; F(3, 5, 10, f); vcl_cerr &lt;&lt; " F 前n位被数组自动赋值" &lt;&lt; vcl_endl; printf("F_rows=%d \t F_cols=%d\n", F.rows(), F.cols()); vcl_cerr &lt;&lt; F &lt;&lt; vcl_endl; //矩阵 double g[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 &#125;; vnl_matrix&lt;double&gt; G(g, 3, 5); vcl_cerr &lt;&lt; " G 被一块内存初始化" &lt;&lt; vcl_endl; printf("G_rows=%d \t G_cols=%d\n", G.rows(), G.cols()); vcl_cerr &lt;&lt; G &lt;&lt; vcl_endl;&#125;]]></content>
      <tags>
        <tag>工具的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMakeLists的编写]]></title>
    <url>%2F2017%2F11%2F01%2FCMakeLists%E7%9A%84%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[CMake工具的理解CMake是一个很方便的跨平台编译的软件，他可以输出各种各样的makefile或者project文件。因为本人经常需要将windows上编写的程序放到linux上进行编译运行等，所以如果自己手动去一个一个编译，去链接各种库；这个时候CMake就可以帮助我们来解决这些麻烦的问题，他不仅仅可以帮助我们生成相应的makefile和project，还会帮助我们去查找系统中所安装的一些依赖库，帮我们做好链接工作【当然，如果我们有些库没有设置环境变量的话，可能会找不到，但是这个时候在windows上我们可以手动添加，在linux上面我们可以通过ccmake来进入可视化界面进行添加或者使用cmake后面加上指令进行添加】。 当然CMake工具也要知道我们的工程需要干什么等，这个时候我们就需要编写CMakeLists.txt文件来告诉计算机我这个工程用到了哪些库，里面的文件是如何链接的等。 CMakeLists.txt的编写下面是我自己编写的一个例子： 在这个例子中，我生成了一个名字叫VNL的工程，并且在该工程中我链接了VXL这个库,并且有一个IO接口，这个IO中我们可以编写自己的函数然后生成lib供主函数来调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#=========================================================================# $Author$# $Date$# $Revision$#=========================================================================CMAKE_MINIMUM_REQUIRED(VERSION 2.4)IF(COMMAND cmake_policy) cmake_policy(SET CMP0003 NEW)ENDIF(COMMAND cmake_policy)PROJECT(VNL)FIND_PACKAGE(VXL) IF(VXL_FOUND) INCLUDE($&#123;VXL_CMAKE_DIR&#125;/UseVXL.cmake)ENDIF(VXL_FOUND)IF(WIN32)ADD_DEFINITIONS(-D_ALLOW_KEYWORD_MACROS)ENDIF(WIN32)#IF( VXL_VNL_FOUND ) INCLUDE_DIRECTORIES( $&#123;VXL_VNL_INCLUDE_DIR&#125; ) SET(IO_API_SRCS common.cpp ) file(GLOB_RECURSE IO_API_HDRS common.h ) ADD_LIBRARY(io_api $&#123;API_LIBRARY_TYPE&#125; $&#123;IO_API_SRCS&#125; $&#123;IO_API_HDRS&#125;)SET( VNL $&#123;VNL&#125; vnl_example.cpp )ADD_EXECUTABLE( VNL $&#123;VNL&#125;)TARGET_LINK_LIBRARIES( VNL io_api vnl_algo vnl vcl netlib) 其他库的调用跟上面的方法类似，如果不会也可以自行百度。 例如下面是打开openmp并行的编写： 1234567FIND_PACKAGE( OpenMP REQUIRED) if(OPENMP_FOUND) message("OPENMP FOUND") set(CMAKE_C_FLAGS "$&#123;CMAKE_C_FLAGS&#125; $&#123;OpenMP_C_FLAGS&#125;") set(CMAKE_CXX_FLAGS "$&#123;CMAKE_CXX_FLAGS&#125; $&#123;OpenMP_CXX_FLAGS&#125;") set(CMAKE_EXE_LINKER_FLAGS "$&#123;CMAKE_EXE_LINKER_FLAGS&#125; $&#123;OpenMP_EXE_LINKER_FLAGS&#125;") endif() 注：编写CMakelist的时候要注意一下各个的包含关系等，以及库的调用，还有名字等。]]></content>
      <tags>
        <tag>工具的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GPU监测时问题解决]]></title>
    <url>%2F2017%2F10%2F19%2FGPU%E7%9B%91%E6%B5%8B%E6%97%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[GPU监测时问题解决不管在我们使用服务器还是使用自己的桌面版本的时候，跑程序时一方面，有时候我们会监测一下电脑的资源使用情况,但是监测的时候我们可以能会遇到一些问题。对于CPU资源的使用，我们可以使用top或者使用更高级的htop指令进行监测，这个里面包含了很多的信息。对于GPU资源的使用，我们一般使用nvidia-smi来进行一个监测，因为该指令是一个静态的，所以如果我们想动态的监测GPU的使用情况，我们可以配合watch指令进行使用，watch -n 1 nvidia-smi. 以上是我们使用一些基本方法，但是我在监测GPU的时候，可能会遇到以下两个问题： 1、GPU明明没有在用，但是显示的时候却显示GPU的利用率却很高，但是再看功率的时候又可以肯定GPU并没有在使用； 2、当一个用户用GPU跑完程序后，关掉了程序，但是GPU依旧显示该程序占用内存。 解决方法针对以上的两个问题，本人的解决方法如下 GPU监测时显示不准确对于GPU监测显示不准确时的指令如下：1sudo nvidia-smi -pm 1 GPU内存没有清零对于程序结束了，但是GPU内存没有被清零的情况，解决方案如下： 使用nvidia-smi指令进行查找没有释放内存的程序的PID；然后使用如下指令进行释放：1sudo kill -9 PID 参考资料https://serverfault.com/questions/809038/why-is-my-cuda-gpu-util-70-when-there-are-no-running-processes-found http://blog.csdn.net/lgh0824/article/details/77096241]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互信息]]></title>
    <url>%2F2017%2F09%2F17%2F%E4%BA%92%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[互信息在做医学图像分割时需要用到互信息来计算两幅图像的相似度。之前写好了函数，在此备份。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576float MI_hhl(float ***Img1, float ***Img2, int Image_X_Size, int Image_Y_Size, int Image_Z_Size)&#123; //绘制直方图 int Hist_Img1[256], Hist_Img2[256]; for (int t = 0; t &lt; 256; t++) &#123; Hist_Img1[t] = 0; Hist_Img2[t] = 0; &#125; for (int k = 0; k &lt; Image_Z_Size; k++) &#123; for (int i = 0; i &lt; Image_X_Size; i++) &#123; for (int j = 0; j&lt;Image_Y_Size; j++) &#123; Hist_Img1[(int)Img1[k][i][j]]++; Hist_Img2[(int)Img2[k][i][j]]++; &#125; &#125; &#125; //绘制两个图像的联合直方图 int Hist[256][256]; for (int i = 0; i &lt; 256; i++) &#123; for (int j = 0; j &lt; 256; j++) &#123; Hist[i][j] = 0; &#125; &#125; for (int k = 0; k &lt; Image_Z_Size; k++) &#123; for (int i = 0; i &lt; Image_X_Size; i++) &#123; for (int j = 0; j&lt;Image_Y_Size; j++) &#123; Hist[(int)Img1[k][i][j]][(int)Img2[k][i][j]]++; &#125; &#125; &#125; //计算单个概率 float P_Img1[256], P_Img2[256]; float all_number; all_number = Image_X_Size * Image_Y_Size * Image_Z_Size; for (int t = 0; t &lt; 256; t++) &#123; P_Img1[t] = (float)Hist_Img1[t] / all_number; P_Img2[t] = (float)Hist_Img2[t] / all_number; &#125; //计算联合概率 float P_Hist[256][256]; for (int i = 0; i &lt; 256; i++) &#123; for (int j = 0; j &lt; 256; j++) &#123; P_Hist[i][j] = (float)Hist[i][j] / all_number; &#125; &#125; //计算两个图像的互信息 float Mut_INF = 0; for (int i = 0; i &lt; 256; i++) &#123; for (int j = 0; j &lt; 256; j++) &#123; if (P_Hist[i][j] == 0 || P_Img1[i] == 0 || P_Img2[j] == 0) &#123; continue; &#125; Mut_INF += P_Hist[i][j] * log10(P_Hist[i][j] / (P_Img1[i] * P_Img2[j])); &#125; &#125; return Mut_INF;&#125;]]></content>
      <tags>
        <tag>医学图像分割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于距离的计算方法]]></title>
    <url>%2F2017%2F09%2F17%2F%E5%9F%BA%E4%BA%8E%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基于距离的计算方法在因为之前项目中用到了欧氏距离，所以在网上看了一下，然后感觉还不错就转载到自己的笔记中。顺便测试了一下在博客中直接编写公式。 本文转自：http://blog.sina.com.cn/s/blog_52510b1d01015nrg.html 欧氏距离(Euclidean Distance)欧氏距离是最易于理解的一种距离计算方法，源自欧氏空间中两点间的距离公式。 (1)二维平面上两点a(x1,y1)与b(x2,y2)间的欧氏距离： d_{12}=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}(2)三维空间两点a(x1,y1,z1)与b(x2,y2,z2)间的欧氏距离： d_{12}=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}(3)两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的欧氏距离： d_{12}=\sqrt{\sum_{k=1}^n(x_{1k}-x_{2k})^2}也可以用表示成向量运算的形式： d_{12}=\sqrt{(a-b)(a-b)^T}(4)Matlab计算欧氏距离 Matlab计算距离主要使用pdist函数。若X是一个M×N的矩阵，则pdist(X)将X矩阵M行的每一行作为一个N维向量，然后计算这M个向量两两间的距离。 例子：计算向量(0,0)、(1,0)、(0,2)两两间的欧式距离 X = [0 0 ; 1 0 ; 0 2] D = pdist(X,’euclidean’) 结果： D = 1.0000 2.0000 2.2361 曼哈顿距离(Manhattan Distance)从名字就可以猜出这种距离的计算方法了。想象你在曼哈顿要从一个十字路口开车到另外一个十字路口，驾驶距离是两点间的直线距离吗？显然不是，除非你能穿越大楼。实际驾驶距离就是这个“曼哈顿距离”。而这也是曼哈顿距离名称的来源， 曼哈顿距离也称为城市街区距离(City Block distance)。 (1)二维平面两点a(x1,y1)与b(x2,y2)间的曼哈顿距离 d_{12}=|x_1-x_2|+|y_1-y_2|(2)两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的曼哈顿距离 d_{12}=\sum_{k=1}^n|x_{1k}-x_{2k}|(3) Matlab计算曼哈顿距离 例子：计算向量(0,0)、(1,0)、(0,2)两两间的曼哈顿距离 X = [0 0 ; 1 0 ; 0 2] D = pdist(X, ‘cityblock’) 结果： D = 1 2 3 标准化欧氏距离(Standardized Euclidean distance )(1)标准欧氏距离的定义 标准化欧氏距离是针对简单欧氏距离的缺点而作的一种改进方案。标准欧氏距离的思路：既然数据各维分量的分布不一样，好吧！那我先将各个分量都“标准化”到均值、方差相等吧。均值和方差标准化到多少呢？这里先复习点统计学知识吧，假设样本集X的均值(mean)为m，标准差(standard deviation)为s，那么X的“标准化变量”表示为： 而且标准化变量的数学期望为0，方差为1。因此样本集的标准化过程(standardization)用公式描述就是： X^* = \frac{X-m}{s}标准化后的值 = ( 标准化前的值 － 分量的均值 ) /分量的标准差 经过简单的推导就可以得到两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的标准化欧氏距离的公式： d_{12}=\sqrt{\sum_{k=1}^n(\frac{x_{1k}-x_{2k}}{s_k})^2}如果将方差的倒数看成是一个权重，这个公式可以看成是一种加权欧氏距离(Weighted Euclidean distance)。 (2)Matlab计算标准化欧氏距离 例子：计算向量(0,0)、(1,0)、(0,2)两两间的标准化欧氏距离 (假设两个分量的标准差分别为0.5和1) X = [0 0 ; 1 0 ; 0 2] D = pdist(X, ‘seuclidean’,[0.5,1]) 结果： D = 2.0000 2.0000 2.8284 夹角余弦(Cosine)有没有搞错，又不是学几何，怎么扯到夹角余弦了？各位看官稍安勿躁。几何中夹角余弦可用来衡量两个向量方向的差异，机器学习中借用这一概念来衡量样本向量之间的差异。 (1)在二维空间中向量A(x1,y1)与向量B(x2,y2)的夹角余弦公式： \cos \theta = \frac{x_1x_2+y_1y_2}{\sqrt{x_1^2+y_1^2} \sqrt{x_2^2+y_2^2}}(2) 两个n维样本点a(x11,x12,…,x1n)和b(x21,x22,…,x2n)的夹角余弦 类似的，对于两个n维样本点a(x11,x12,…,x1n)和b(x21,x22,…,x2n)，可以使用类似于夹角余弦的概念来衡量它们间的相似程度。 \cos(\theta)=\frac{a \cdot b}{|a||b|}即： \cos(\theta)=\frac{\sum_{k=1}^n x_{1k}x_{2k}}{\sqrt{\sum_{k=1}^nx_{1k}^2}\sqrt{\sum_{k=1}^nx_{2k}^2}}夹角余弦取值范围为[-1,1]。夹角余弦越大表示两个向量的夹角越小，夹角余弦越小表示两向量的夹角越大。当两个向量的方向重合时夹角余弦取最大值1，当两个向量的方向完全相反夹角余弦取最小值-1。 (3)Matlab计算夹角余弦 例子：计算(1,0)、( 1,1.732)、( -1,0)两两间的夹角余弦 X = [1 0 ; 1 1.732 ; -1 0] D = 1- pdist(X, ‘cosine’) % Matlab中的pdist(X, ‘cosine’)得到的是1减夹角余弦的值 结果： D = 0.5000 -1.0000 -0.5000]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh连接服务器中断，如何让命令继续在服务器执行]]></title>
    <url>%2F2017%2F09%2F08%2Fssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E6%96%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%A9%E5%91%BD%E4%BB%A4%E7%BB%A7%E7%BB%AD%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[ssh连接linux服务器中断后，如何让命令继续在服务器运行这个问题也许是我们这些小白比较头疼的问题，尤其对于那些做机器学习需要花很久的时间才能训练出一个结果。然而就在这时，因为各种不可抗力我们使用ssh连接服务器时，ssh的窗口突然断开了连接，那么在服务器上跑的程序就也跟着断掉了，之前所有跑的数据也将丢失，这样将会浪费我们大量的时间。 今天刚好有人跟我提到了这个问题，然后就简单上网查找资料，简单的学习一下，做个笔记方便自己以后查阅。 参考链接： http://blog.csdn.net/gukesdo/article/details/6901902 为什么ssh一旦断开我们的进程也将会被杀掉？元凶：SIGHUP 信号 让我们来看看为什么关掉窗口/断开连接会使得正在运行的程序死掉。 在Linux/Unix中，有这样几个概念： 进程组（process group）：一个或多个进程的集合，每一个进程组有唯一一个进程组ID，即进程组长进程的ID。 会话期（session）：一个或多个进程组的集合，有唯一一个会话期首进程（session leader）。会话期ID为首进程的ID。 会话期可以有一个单独的控制终端（controlling terminal）。与控制终端连接的会话期首进程叫做控制进程（controlling process）。当前与终端交互的进程称为前台进程组。其余进程组称为后台进程组。 根据POSIX.1定义： 挂断信号（SIGHUP）默认的动作是终止程序。 当终端接口检测到网络连接断开，将挂断信号发送给控制进程（会话期首进程）。 如果会话期首进程终止，则该信号发送到该会话期前台进程组。 一个进程退出导致一个孤儿进程组中产生时，如果任意一个孤儿进程组进程处于STOP状态，发送SIGHUP和SIGCONT信号到该进程组中所有进程。 因此当网络断开或终端窗口关闭后，控制进程收到SIGHUP信号退出，会导致该会话期内其他进程退出。 这里我认为我们的进程被杀掉也就是因为ssh与服务器之间的通信断掉了，这个通信断掉之后linux程序就默认将该连接下的所有进程都杀掉 解决方案针对上面的问题，上面的参考链接中也有讲解，在此进行一个简单的整理。 这里主要有两个方案，一个是使用nohup指令，另一个是使用screen指令。看完这两个指令之后其实我更倾向于使用screen指令，因为screen指令更加的强大。 nohup命令nohup命令参考 nohup 命令 用途：不挂断地运行命令。 语法：nohup Command [ Arg … ] [ &amp; ] 描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断(SIGHUP)信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; ( 表示”and”的符号)到命令的尾部。 无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。 nohup的简单使用在执行命令时在命令前面加上nohup，然后回车开始运行。 这时你会发现该有的输出其实并没有输出出来，这个时候不要方，这是因为nohup命令将你的所有输出都输出到了当前文件夹下的nohup.out文件中，自己可以使用vim指令进行一个查看。 nohup命令及其输出文件 nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。 该命令的一般形式为：nohup command &amp; 使用nohup命令提交作业 如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件： nohup command &gt; myout.file 2&gt;&amp;1 &amp; 使用 jobs 查看任务。 使用 fg %n 关闭。 screen命令简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。在screen中创建一个新的窗口有这样几种方式： 1．直接在命令行键入screen命令 $ screenScreen将创建一个执行shell的全屏窗口。你可以执行任意shell程序，就像在ssh窗口中那样。在该窗口中键入exit退出该窗口，如果这是该screen会话的唯一窗口，该screen会话退出，否则screen自动切换到前一个窗口。 2．Screen命令后跟你要执行的程序。 $ screen 【后面跟你执行程序的命令】 Screen创建一个执行vi test.c的单窗口会话，退出vi将退出该窗口/会话。 3．以上两种方式都创建新的screen会话。我们还可以在一个已有screen会话中创建新的窗口。在当前screen窗口中键入C-a c ，即Ctrl键+a键，之后再按下c键，screen 在该会话内生成一个新的窗口并切换到该窗口。 screen还有更高级的功能。你可以不中断screen窗口中程序的运行而暂时断开（detach）screen会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。 screen的简单使用在所要执行的指令前添加screen.然后程序的运行等一切正常。（nohup的输出是定向到了nohup.out文件中，然而screen指令的输出是直接输出到了屏幕上的） 这个时候如果ssh终端断开了连接。我们只需要再次连接服务器然后输入指令 1screen -ls 然后会得到类似下面的结果： 123There is a screen on: 27267.pts-19.TITAN-X (09/08/2017 03:49:10 PM) (Detached)1 Socket in /var/run/screen/S-huanghailiang. 这里就会显示ssh断开之前的程序，其实断开后程序依然在后台在运行，只是我们这个时候需要将它放到前台来运行。这个时候我们们已经通过screen -ls查询到了线程号是27267了，所以我们只需要执行下面的指令即可恢复到前台了。 1screen -r 27267 如果想杀掉终端可以执行 1kill 27267 其他更多的指令可以通过screen —help来进行学习。 当然screen还有更多的快捷键值得我们学习。我们可以通过C-a ? 即先按ctrl+a以后再按？即可查看。 通过观察我们可以发现它其实恢复了我们ssh断开前的那个界面。（所有的输出也都会在此显示出来） 注（个人理解）：nohup虽然可以把所有的输出都写入到nohup.out中间来，但是在面对需要人机交互的时候它就不能正常使用了。另外在我做测试的时候，一旦ssh断开，虽然程序还在后台运行，但是好像并不会再把输出写入到nohup.out文件中，这一点很不好。 screen相比之下就强大了很多，不仅可以满足人机交互，而且还可以将所有的输出都再次展示出来，方便我们查看。我对screen的理解是，其实它是一个虚拟的终端，我们运行的时候screen指令就为我们创建了一个虚拟的终端，所以我们再次连接后我们打开的还是这个虚拟的终端，所以我们可以更好的进行操作，而且screen支持开很多个终端。 它们两者的共性我认为都已经不受SIGHUP信号的影响了，所以即使断掉了ssh程序依旧会运行。]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速哈达玛变换]]></title>
    <url>%2F2017%2F09%2F06%2F%E5%BF%AB%E9%80%9F%E5%93%88%E8%BE%BE%E7%8E%9B%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[快速哈达玛变换在生成哈达玛矩阵的文章中我已经提到了沃尔什函数，其实也就是快速哈达玛变换，他是针对与压缩感知中压缩过程中对哈达玛矩阵的行进行一个变换，这么做可以更好的压缩图像，并更好的进行解压。 快速哈达玛矩阵的代码实现简单的实现就是写成二进制表示没然后保存反向格雷码就是新矩阵所对应的行号。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define M 128int num = 1; //需要转换的数int number = 0;int Gray_number(int num_h)&#123; int binary[30];//保存反向二进制的值 int Gray[30];//保存反向格雷码 //////////////////// int M_m = M - 1; int M_num = 0; while (1) &#123; M_m = M_m / 2; M_num++; printf("M_num=%d", M_num); if (M_m == 0) &#123; break; &#125; &#125; //////////////////// printf("num_h=%d", num_h); printf("\n"); int i = 0; while (1) &#123; binary[i] = num_h % 2; printf("\ni=%d binary[i]=%d\n", i, binary[i]); num_h = num_h / 2; i++; if (num_h == 0) &#123; break; &#125; &#125; /////////////// printf("\ni=%d\n", i); for (i = i; i&lt;M_num; i++) &#123; binary[i] = 0; printf("\ni=%d binary[i]=%d\n", i, binary[i]); &#125; //////////// int j = 0; for (j = 0; j&lt;i; j++) &#123; printf("binary[j]=%d %d\n", binary[j], j); &#125; printf("\n%d", i); //得到反向的格雷码 int k = 0, Gray_num = 0; for (k = 0; k&lt;i - 1; k++) &#123; if ((binary[k] - binary[k + 1]) == 0) &#123; Gray_num = 0; &#125; else &#123; Gray_num = 1; &#125; Gray[k] = Gray_num; &#125; Gray[i - 1] = binary[i - 1]; printf("\nGray\n", i); for (j = 0; j&lt;i; j++) &#123; printf("%d", Gray[j]); &#125; printf("\nlast number\n", i); for (j = 0; j&lt;i; j++) &#123; number += Gray[j] * pow((double)2, (int)(i - j - 1)); &#125; printf("number=%d", number); printf("\n"); return number;&#125;int main()&#123; Gray_number(num); printf("\n"); printf("\n"); printf("\n"); printf("number=%d", number);&#125;]]></content>
      <tags>
        <tag>常用的C语言小程序代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成哈达玛矩阵]]></title>
    <url>%2F2017%2F09%2F06%2F%E7%94%9F%E6%88%90%E5%93%88%E8%BE%BE%E7%8E%9B%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[哈达玛矩阵是什么哈达玛（Hadamard)矩阵是由+1和-1元素构成的正交方阵。所谓正交方阵，指它的任意两行（或两列）都是正交的，且任意一行（列）的所有元素的平方和等于方阵的阶数。即：设A为n阶由+1和-1元素构成的方阵，若AA‘=nI（这里A’为A的转置，I为单位方阵），则称A为n阶Hadamard矩阵。 已有人证明，Hadamard矩阵的阶数都是4的倍数。 哈达玛矩阵的应用本人使用哈达玛矩阵是在压缩感知中知道的，在压缩中进行快速哈达玛变换（沃尔什函数）的变换以后就可以进行图像压缩，之后在运用TVAL3算法就可以进行一个解压缩，来还原原来的图像。现在的压缩比基本都在10%之下。 哈达玛矩阵生成的代码这里的M和N表示矩阵的大小。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#define M 32 #define N 32int Hadamard[M][N];//生成哈达玛矩阵的函数int CreateHadmard(int i, int j)&#123; long k, temp, result = 0; temp = i&amp;j; for (k = 0; k&lt;32; k++) &#123; result = result + (temp &gt;&gt; k) &amp; 1; &#125; if (result % 2 == 0) &#123; return 1; &#125; else &#123; return -1; &#125;&#125;int main()&#123; int i, j; printf("生成哈达玛矩阵\n"); for (i = 0; i&lt;M; i++) &#123; for (j = 0; j&lt;N; j++) &#123; Hadamard[i][j] = CreateHadmard(i, j); printf("%3d", Hadamard[i][j]); &#125; printf("\n"); &#125;&#125;]]></content>
      <tags>
        <tag>常用的C语言小程序代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言读取系统当前时间]]></title>
    <url>%2F2017%2F09%2F06%2FC%E8%AF%AD%E8%A8%80%E8%AF%BB%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[C语言读取系统当前时间之前编程的时候我们需要来读取当前的时间，或者使用当前的时间对文件进行一个命名等，所以做一个笔记用来备忘。 读取时间代码C语言读取系统时间的代码如下： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt;#include &lt;string.h&gt; int main()&#123; time_t timep,Tim; struct tm *p; time(&amp;timep); p = localtime(&amp;timep); //此函数获得的tm结构体的时间，是已经进行过时区转化为本地时间 //p = gmtime(&amp;timep); //把日期和时间转换为格林威治(GMT)时间的函数 int Year = 1900 + p-&gt;tm_year; int Month = 1 + p-&gt;tm_mon; int Day = p-&gt;tm_mday; int Hour = p-&gt;tm_hour; int Minute = p-&gt;tm_min; int Second = p-&gt;tm_sec; char year[20]; char month[20]; char day[20]; char hour[20]; char minute[20]; char second[20]; printf("year=%d\n",Year); printf("month=%d\n", Month); printf("day=%d\n", Day); printf("hour=%d\n", Hour); printf("minute=%d\n", Minute); printf("second=%d\n", Second); return 0; &#125; 以上为简单的系统时间读取。在Windows环境下好像运行是有问题的，这个时候需要在预编译头那里添加 _CRT_SECURE_NO_WARNINGS即可。 localtime函数获得的tm结构体的时间，是已经进行过时区转化为本地时间，然而gmtime函数是把日期和时间转换为格林威治(GMT)时间的函数。 要用这个时间对文件进行命名在我们进行编程的时候有时候需要对文件进行命名，有时候一个程序是不停的循环运行的，我们还要区分程序跑出来的文件结果，所以这个时候我们如果使用时间来对文件命名的话就会方便很多，而且一定不会因为重名而被覆盖。 这个时候我们可以用sprintf和strcat这两个函数进行一个组合。简单的例子如下： 123456789101112131415161718192021 char name[100] = "1616_";char year[20];char month[20];char day[20];char hour[20];char minute[20];char second[20];char txt[5] = ".txt"; sprintf(year, "%d", Year);sprintf(month, "%d", Month);sprintf(day, "%d", Day);sprintf(hour, "%d", Hour);sprintf(minute, "%d", Minute);sprintf(second, "%d", Second);strcat(name, year);strcat(name, month);strcat(name, day);strcat(name, hour);strcat(name, minute);strcat(name, second);strcat(name, txt);]]></content>
      <tags>
        <tag>常用的C语言小程序代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用C语言自己写2048]]></title>
    <url>%2F2017%2F09%2F05%2F2048%2F</url>
    <content type="text"><![CDATA[用C语言自己写20482048是之前非常火爆的一个游戏，记得之前上课的时候很多同学都在玩这个游戏。尤其是一些比较无聊的课上玩的人更多。那么我们应该如何用代码自己来实现2048这个游戏的编写呢？ 之前在实验楼网站学习linux的时候碰巧看到了一个教程，所以就试着玩了一下，代码编写也很简单，当然我也无聊的玩到了2048，所以我发现其实实验楼上面给的代码也是有点小bug的，所以我对代码进行了一个简单的更改。 实验楼该教程网址： https://www.shiyanlou.com/courses/155 下面就是操作及其我修改后的代码： 基础知识要实现我们的 2048 小游戏，需要涉及一些数据结构的知识，以及一些 Linux 的系统调用。此外，为了方便在屏幕上使用字符绘图，我们还需要使用一个文本界面的屏幕绘图库 ncurses ，具体到操作就是在编译的时候需要加上 -lcurses 选项。 ncurses 库的安装操作如下：1sudo apt-get install libncurses5-dev 我修改后的代码创建一个c文件，命名为2048.c 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;curses.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;// 4*4方格int a[4][4] = &#123;0&#125;;// 方格里空格的个数int empty;int old_y, old_x;void draw();void play();void init();void draw_one(int y, int x);void cnt_value(int *new_y, int *new_x);int game_over();int cnt_one(int y, int x);int main()&#123; init(); play(); endwin(); return 0;&#125;void init()&#123; int x, y; initscr(); cbreak(); noecho(); curs_set(0); empty = 15; srand(time(0)); x = rand() % 4; y = rand() % 4; a[y][x] = 2; draw();&#125;void draw()&#123; int n, m, x, y; char c[4] = &#123;'0', '0', '0', '0'&#125;; clear(); for(n = 0; n &lt; 9; n += 2) //横线 for(m = 0; m &lt; 21; m++) &#123; move(n, m); addch('-'); refresh(); &#125; for(m = 0; m &lt; 22; m += 5) //竖线 for(n = 1; n &lt; 8; n++) &#123; move(n, m); addch('|'); refresh(); &#125; for(y = 0; y &lt; 4; y++) //数字 for(x = 0; x &lt; 4; x++) &#123; draw_one(y, x); &#125;&#125;void draw_one(int y, int x)&#123; int i, m, k, j; char c[4] = &#123;'0', '0', '0', '0'&#125;; i = a[y][x]; m = 0; do &#123; j = i % 10; c[m++] = j + '0'; i = i / 10; &#125;while(i &gt; 0); m = 0; k = (x + 1) * 5 - 1; while(c[m] != '0') &#123; move(2*y+1, k); addch(c[m++]); k--; &#125;&#125;void play()&#123; int x, y, i, new_x, new_y, tmp; int old_empty, move; char ch; while(1) &#123; move = 0; old_empty = empty; //draw(); ch = getch(); switch(ch) &#123; case 'A': case 'a': //从左向右消去相同方块 for(y = 0; y &lt; 4; y++) for(x = 0; x &lt; 4; ) &#123; if(a[y][x] == 0) &#123; x++; continue; &#125; else &#123; for(i = x + 1; i &lt; 4; i++) &#123; if(a[y][i] == 0) &#123; continue; &#125; else &#123; if(a[y][x] == a[y][i]) &#123; a[y][x] += a[y][i]; a[y][i] = 0; x = i + 1; empty++; break; &#125; else &#123; x = i; break; &#125; &#125; &#125; x = i; &#125; &#125; //向左移动方块 for(y = 0; y &lt; 4; y++) for(x = 0; x &lt; 4; x++) &#123; if(a[y][x] == 0) &#123; continue; &#125; else &#123; for(i = x; (i &gt; 0) &amp;&amp; (a[y][i-1] == 0); i--) &#123; a[y][i-1] = a[y][i]; a[y][i] = 0; move = 1; &#125; &#125; &#125; break; case 'D': case 'd': //从右向左消去相同方块 for(y = 0; y &lt; 4; y++) for(x = 3; x &gt;= 0; ) &#123; if(a[y][x] == 0) &#123; x--; continue; &#125; else &#123; for(i = x - 1; i &gt;= 0; i--) &#123; if(a[y][i] == 0) &#123; continue; &#125; else if(a[y][x] == a[y][i]) &#123; a[y][x] += a[y][i]; a[y][i] = 0; x = i - 1; empty++; break; &#125; else &#123; x = i; break; &#125; &#125; x = i; &#125; &#125; //向右移动方块 for(y = 0; y &lt; 4; y++) for(x = 3; x &gt;= 0; x--) &#123; if(a[y][x] == 0) &#123; continue; &#125; else &#123; for(i = x; (i &lt; 3) &amp;&amp; (a[y][i+1] == 0); i++) &#123; a[y][i+1] = a[y][i]; a[y][i] = 0; move = 1; &#125; &#125; &#125; break; case 'W': case 'w': //从上向下消去相同方块 for(x = 0; x &lt; 4; x++) for(y = 0; y &lt; 4; ) &#123; if(a[y][x] == 0) &#123; y++; continue; &#125; else &#123; for(i = y + 1; i &lt; 4; i++) &#123; if(a[i][x] == 0) &#123; continue; &#125; else if(a[y][x] == a[i][x]) &#123; a[y][x] += a[i][x]; a[i][x] = 0; y = i + 1; empty++; break; &#125; else &#123; y = i; break; &#125; &#125; y = i; &#125; &#125; //向上移动方块 for(x = 0; x &lt; 4; x++) for(y = 0; y &lt; 4; y++) &#123; if(a[y][x] == 0) &#123; continue; &#125; else &#123; for(i = y; (i &gt; 0) &amp;&amp; (a[i-1][x] == 0); i--) &#123; a[i-1][x] = a[i][x]; a[i][x] = 0; move = 1; &#125; &#125; &#125; break; case 'S': case 's': //从下向上消去相同方块 for(x = 0; x &lt; 4; x++) for(y = 3; y &gt;= 0; ) &#123; if(a[y][x] == 0) &#123; y--; continue; &#125; else &#123; for(i = y - 1; i &gt;= 0; i--) &#123; if(a[i][x] == 0) &#123; continue; &#125; else if(a[y][x] == a[i][x]) &#123; a[y][x] += a[i][x]; a[i][x] = 0; y = i -1; empty++; break; &#125; else &#123; y = i; break; &#125; &#125; y = i; &#125; &#125; //向下移动方块 for(x = 0; x &lt; 4; x++) for(y = 3; y &gt;= 0; y--) &#123; if(a[y][x] == 0) &#123; continue; &#125; else &#123; for(i = y; (i &lt; 3) &amp;&amp; (a[i+1][x] == 0); i++) &#123; a[i+1][x] = a[i][x]; a[i][x] = 0; move = 1; &#125; &#125; &#125; break; case 'Q': case 'q': game_over(); break; default: continue; break; &#125; if(empty &lt;= 0) game_over(); draw(); //生成新方块 if((empty != old_empty) || (move == 1)) &#123; //修复了不移动或消除方块也生成新方块的bug do &#123; new_x = rand() % 4; new_y = rand() % 4; &#125;while(a[new_y][new_x] != 0); cnt_value(&amp;new_y, &amp;new_x); do &#123; tmp = rand() % 4; &#125;while(tmp == 0 || tmp == 2); a[new_y][new_x] = tmp + 1; empty--; draw_one(new_y, new_x); &#125; &#125;&#125;int cnt_one(int y, int x)&#123; int value = 1; if(y - 1 &gt; 0) a[y-1][x] ? 0 : value++; if(y + 1 &lt; 4) a[y+1][x] ? 0 : value++; if(x - 1 &gt;= 0) a[y][x-1] ? 0 : value++; if(x + 1 &lt; 4) a[y][x+1] ? 0 : value++; if(y - 1 &gt;= 0 &amp;&amp; x - 1 &gt;= 0) a[y-1][x-1] ? 0 : value++; if(y - 1 &gt;= 0 &amp;&amp; x + 1 &lt; 4) a[y-1][x+1] ? 0 : value++; if(y + 1 &lt; 4 &amp;&amp; x - 1 &gt;= 0) a[y+1][x-1] ? 0 : value++; if(y + 1 &lt; 4 &amp;&amp; x + 1 &lt; 4) a[y+1][x+1] ? 0 : value++; return value;&#125;void cnt_value(int *new_y, int *new_x)&#123; int max_x, max_y, x, y, value; int max = 0; max = cnt_one(*new_y, *new_x); for(y = 0; y &lt; 4; y++) for(x = 0; x &lt; 4; x++) &#123; if(!a[y][x]) &#123; value = cnt_one(y, x); if(value &gt; max &amp;&amp; old_y != y &amp;&amp; old_x != x) &#123; //避免在同一位置反复出现新方块 *new_y = y; *new_x = x; old_x = x; old_y = y; break; &#125; &#125; &#125;&#125;int game_over()&#123; sleep(1); endwin(); exit(0);&#125; 编译程序1gcc 2048.c -o 2048 -lcurses 运行程序1./2048 操作使用“w”;”a”;”s”;”d”;或者”W”;”A”;”S”;”D”来进行移动 效果图如下：]]></content>
      <tags>
        <tag>娱乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu server 硬盘挂载教程]]></title>
    <url>%2F2017%2F09%2F05%2FUbuntu-server-%E7%A1%AC%E7%9B%98%E6%8C%82%E8%BD%BD%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Ubuntu server 硬盘挂载教程在我们使用服务器的时候，因为使用的人比较多，而且目前做机器学习的人比较多，然而机器学习那边需要训练一些数据，训练集比较大，这就对于我们服务器的存储能力是一个较大的体验，所以一块硬盘已经不能满足我们的需求，我们需要使用多块硬盘来一起存储我们的数据，但是Ubuntu系统要识别多块硬盘需要我们自己配置。 本人认为有以下几种方法： 1、在安装Ubuntu系统的时候，我们可以手动配置挂载。（这个我们有尝试过，不过理论上应该是可以实现的，不过我们一般比较懒，所以会选择自动分配，这样我们比较省事。然而自动分配的话，系统会让你自己选择一个空硬盘或者一个连续的没有用的磁盘空间进行。） 2、设置磁盘阵列（比如raid），这个好像也是要在安装系统前进行。简单来说就是将多块磁盘的逻辑分区方放到一起来当作一块使用。（不知道这样的理解对不对，不过呢，个人感觉实际效果就是这个样子的）然后再正常安装选择硬盘的时候你会发现有一个很大的硬盘。（当然这种方法可能也有一些限制，比如两块硬盘的大小要一样等要求，需要自己去找）。 如果系统已经装好了，我们要用上面的两种方法我觉得很不现实的，所以有些时候我们需要另想办法的。 3、可以使用LVM技术来创建逻辑分区，这个我在网上看到过，网址如下，感觉讲的还是比较详细的。 参考网址：http://blog.csdn.net/it_yuan/article/details/19242445 4、可以直接使用硬盘进行挂载。（也试用于优盘的挂载，不过是服务器版本，一般我们自己用的桌面版本好像它会自动加载优盘的，服务器版本需要自己手动设置的） 参考网址：http://zwkufo.blog.163.com/blog/static/258825120141283942244/ 由于前3种方法我没有亲自尝试，所以这里暂时先不说了，不过网上教程也有的，后面如果有机会的话，我可能会补充进来。所以这里我就简单说一些第四种方法好了。 硬盘挂载 1、 sudo fdisk –lu (查看当前硬盘及分区情况) 可以看到类似界面 2、 sudo fdisk /dev/sdb(这里为想要挂载的硬盘名称)，利用该命令可以对硬盘进行分区，具体可以参考网址中的讲解更加详细 3、 sudo mkfs –t ext4 /dev/sdb(硬盘格式化，-t ext4 表示将分区格式化成ext4文件系统类型) 4、 sudo df –l(显示硬盘挂载情况) sudo mount –t ext4 /dev/sdb(想要挂载的硬盘) /devdata(目标挂载点) 结束后可以用sudo df –l 查看是否成功 5、 配置系统启动自动挂载，修改/etc/fstab文件，添加 /devdata was on /dev/sdb UUID=37eaa526-5d96-4237-8468-603df5216ce9 /devdata(挂载点) ext4 defaults 0 0 UUID通过sudo blkid 可以查看 其实好像输入/dev/sdb也是可以的，例如我在实验室服务器上面的挂载如下：]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git本地库的建立与使用]]></title>
    <url>%2F2017%2F09%2F03%2FGit%E6%9C%AC%E5%9C%B0%E5%BA%93%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git本地库的建立与使用本笔记是自己在网上学习后整理后得到的，主要针对的是本地库的建立以及使用，对于远程库的操作这里暂时不涉及。 本教程的本地库的建立主要是在linux系统上建立，windows上可以使用命令行的git bash 或者带有图形界面的TortoiseGit进行操作，有兴趣的话可以自己学习一下。 在linux版本上：1、打开终端输入git，如果没有安装，按照提示指令进行安装。例如：sudo apt-get install git。如果已经安装会有如下显示 2、Git的配置设置你的名字和email,就是你提交commit时的签名，每次提交记录里面都会包含这些信息。使用git config命令进行设置。 执行后会在根目录下建立一个叫.gitconfig的文件（该文件为隐藏文件需要使用ls -la查看到） 其中隐藏文件.gitconfig的内容可以使用vim或者cat进行查看 3、获取一个Git仓库，这里有两种方法，一种是直接clone一个仓库，另一个是初始化一个仓库。这里我们可以直接自己初始化一个仓库，当然clone仓库也是比较简单的，自己看一下就好。首先需要自己创建一个仓库文件夹，路径什么的自己选择就好，创建使用mkdir就好。例如：mkdir project 就是创建了一个叫project的文件。这里我之前自己手动建立好了一个文件夹就直接使用cd命令进去就好了。初始化Git仓库使用git init命令，Git输出如下。 使用ls -la 可以看出来有一个.git目录被创建，意味着仓库被初始化。 4、git仓库已经被创建好了，接下来就是一些基本操作了。 基本流程：（1）、创建或者修改文件（2）、使用git add命令添加新创建或修改的文件到本地的缓存区（Index）。使用的时候是git add &lt;文件名&gt;或者git add 这说明添加当前文件夹下的所有文件。 （3）、使用git commit命令提交到本地代码库。git commit -m “双引号中间是你们提交代码时写的备注” 使用-m的目的是为了添加本次修改的注释，完成后就会记录一个新的版本。除了用git add命令，我们还可以使用git commit -a -m “双引号中间是你们提交代码时写的备注” 将所有没有加入到缓存区的修改也一起提交，但是 -a命令不能添加新建文件。 （4）（这一步我们的工程不需要，因为我们不需要同步到远程的代码库，因为同步到远程的代码库后相当于开源给了所有人,但是后期你们自己使用git的时候是可以使用的）使用git push命令将本地代码库同步到远端代码库。 git status命令查看当前git仓库的状态。 git commit提交了本地代码库以后，可以是使用git diff 命令再加上 —cached参数，看看缓存区中哪些文件被修改了。进入到git diff —cached界面后需要输入q才可以退出。如果没有 —cached参数，git diff会显示当前你所有已经做的但是没有加入到索引里的修改。所有修改完了以后都需要按照上面的步骤加上缓存区，在用commit提交到本地库。 注：如果是修改文件，也需要使用git add命令添加到缓存区才可以提交。如果是删除文件，则直接使用git rm命令删除后悔自动将已删除文件的信息添加到缓存区，git commit提交后会将本地仓库中的对应文件删除。（【这一步我们不使用】如果本地仓库链接到了远程Git服务器，可以使用git push origin master 命令将本地仓库同步到远端服务器）。 5、git的基本操作以及介绍完了。但是基本都是个人操作的，下面介绍一下如果团队合作的话，每个人写一部分代码，最终合并的话，我们需要使用分支与合并的知识。 （1）、分支 使用 git branch &lt;分支名&gt;来创建分支。这里我将为大家每个人创建一个分支，分支名的命名方式我将使用*表示目前所在的分支。Master是默认的主分支。 使用git checkout &lt;分支名&gt;来选择切换分支，例如下面我将会切换成我自己的分支：由图可以看到*已经跑到了hhl前面说明现在的分支是hhl。 切换到自己的分支以后可以自己更改自己的程序，这样并不会影响到其他分支的程序。 （2）、合并 可以使用git merge命令来进行合并。例如想合并hhl分支到主分支，则需要先切换到主分支上git checkout master 然后再将hhl分支合并到主分支中，git merge -m “这里双引号里面依旧是注释” hhl -m参数仍然是填写合并的注释信息。 注：如果如果两个想要合并的分支都对同一个文件进行了修改，则在合并的时候会有冲突。这个地方需要我们使用vim编辑器手动解决冲突，然后再add再commit提交。 （【这一步也不需要，后期自己使用可以先了解一下】，合并完分支后，如果想删除分支的话使用 git branch -d &lt;分支名&gt;，这个只针对已经被当前分支合并了的分支，如果你想要前置删除某个分支的话使用 git branch -D &lt;分支名&gt;） 撤销合并：如果合并完以后，想要把当前修改都放弃，可以使用 git reset —hard HEAD^ 进行撤销合并。 6、查看日志 git log 命令可以显示所有的提交。如果提交的历史纪录很长，回车会逐步显示，输入q可以退出。 如果用git log —stat 它会显示在每个提交（commit）中哪些文件被修改，这些文件分别添加或删除多少行内容，这个命令相当于打印详细的提交记录。 小结，基本指令： （1）git config :配置相关信息 （2）git clone ：复制仓库 （3）git init :初始化仓库 （4）git add ：添加更新内容到 （5）git diff :比较内容 （6）git status :获取当前项目状况 （7）git commit :提交 （8）git branch :分支相关 （9）git checkout :切换分支 （10）git merge :合并分支 （11）git reset :恢复版本 （12）git log :查看日志]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片转换成字符图]]></title>
    <url>%2F2017%2F09%2F02%2F%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图片转换成字符图因为之前写到了一些好玩的注释模板，当然网上有很多很多好玩的图片，我们不可能完全收集过来，当然也不可能正好有你自己所需要的图片，所以我们需要一个自己将图片转换成字符图的一个代码，这样我们就可以很方便的得到自己想得到的一些字符图。 参考网址实验楼有该教程，个人觉得不错，还给了源码，所以摘抄代码下来学习https://www.shiyanlou.com/courses/370 python实现源码编写ascii.py源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#-*- coding:utf-8 -*-from PIL import Imageimport argparse#命令行输入参数处理parser = argparse.ArgumentParser()parser.add_argument('file') #输入文件parser.add_argument('-o', '--output') #输出文件parser.add_argument('--width', type = int, default = 80) #输出字符画宽parser.add_argument('--height', type = int, default = 80) #输出字符画高#获取参数args = parser.parse_args()IMG = args.fileWIDTH = args.widthHEIGHT = args.heightOUTPUT = args.output#这里的list可以自己定义ascii_char = list("$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\"^`'. ")# 将256灰度映射到70个字符上def get_char(r,g,b,alpha = 256): if alpha == 0: return ' ' length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)]if __name__ == '__main__': im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) txt = "" for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) txt += '\n' print txt #字符画输出到文件 if OUTPUT: with open(OUTPUT,'w') as f: f.write(txt) else: with open("output.txt",'w') as f: f.write(txt) 代码的运行1python ascii.py ascii_dora.png 根据实验楼的效果展示原图 效果图]]></content>
      <tags>
        <tag>娱乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注释模板（仅供娱乐）]]></title>
    <url>%2F2017%2F09%2F02%2F%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF%EF%BC%88%E4%BB%85%E4%BE%9B%E5%A8%B1%E4%B9%90%EF%BC%89%2F</url>
    <content type="text"><![CDATA[注释模板（仅供娱乐）今天无意间在网上看到了一些好玩的注释，让我想起之前开始写代码的时候就已经有人开始在代码中添加这些东西，感觉挺好玩的，随手摘抄，仅供娱乐。 参考网址http://blog.csdn.net/ouyang_peng/article/details/51803181http://www.oschina.net/code/snippet_1046345_43901 在VS中直接设置注释模板因为我只是觉得好玩，所以摘抄一下，具体设置可以参照上面第一个参考网址进行设置。 佛祖保佑 永无bug12345678910111213141516171819202122232425262728293031/** * _ooOoo_ * o8888888o * 88" . "88 * (| -_- |) * O\ = /O * ____/`---'\____ * .' \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| ''\---/'' | | * \ .-\__ `-` ___/-. / * ___`. .' /--.--\ `. . __ * ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-'====== * `=---=' * ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ * 佛祖保佑 永无BUG * 佛曰: * 写字楼里写字间，写字间里程序员； * 程序人员写程序，又拿程序换酒钱。 * 酒醒只在网上坐，酒醉还来网下眠； * 酒醉酒醒日复日，网上网下年复年。 * 但愿老死电脑间，不愿鞠躬老板前； * 奔驰宝马贵者趣，公交自行程序员。 * 别人笑我忒疯癫，我笑自己命太贱； * 不见满街漂亮妹，哪个归得程序员？*/ 12345678910111213141516171819202122////////////////////////////////////////////////////////////////////// _ooOoo_ //// o8888888o //// 88" . "88 //// (| ^_^ |) //// O\ = /O //// ____/`---'\____ //// .' \\| |// `. //// / \\||| : |||// \ //// / _||||| -:- |||||- \ //// | | \\\ - /// | | //// | \_| ''\---/'' | | //// \ .-\__ `-` ___/-. / //// ___`. .' /--.--\ `. . ___ //// ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". //// | | : `- \`.;`\ _ /`;.`/ - ` : | | //// \ \ `-. \_ __\ /__ _/ .-` / / //// ========`-.____`-.___\_____/___.-`____.-'======== //// `=---=' //// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ //// 佛祖保佑 永无BUG 永不修改 ////////////////////////////////////////////////////////////////////// 神兽保佑 代码无BUG！1234567891011121314151617// ┏┓ ┏┓// ┏┛┻━━━┛┻┓// ┃ ┃ // ┃ ━ ┃// ┃ ┳┛ ┗┳ ┃// ┃ ┃// ┃ ┻ ┃// ┃ ┃// ┗━┓ ┏━┛// ┃ ┃ 神兽保佑 // ┃ ┃ 代码无BUG！// ┃ ┗━━━┓// ┃ ┣┓// ┃ ┏┛// ┗┓┓┏━┳┓┏┛// ┃┫┫ ┃┫┫// ┗┻┛ ┗┻┛ 1234567891011121314151617181920212223/** * * ━━━━━━神兽出没━━━━━━ * ┏┓ ┏┓ * ┏┛┻━━━┛┻┓ * ┃ ┃ * ┃ ━ ┃ * ┃ ┳┛ ┗┳ ┃ * ┃ ┃ * ┃ ┻ ┃ * ┃ ┃ * ┗━┓ ┏━┛Code is far away from bug with the animal protecting * ┃ ┃ 神兽保佑,代码无bug * ┃ ┃ * ┃ ┗━━━┓ * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ * * ━━━━━━感觉萌萌哒━━━━━━ */ 1234567891011121314151617181920212223/** * ┏┓ ┏┓ * ┏┛┻━━━┛┻┓ * ┃ ┃ * ┃ ━ ┃ * ┃ ＞ ＜ ┃ * ┃ ┃ * ┃... ⌒ ... ┃ * ┃ ┃ * ┗━┓ ┏━┛ * ┃ ┃ Code is far away from bug with the animal protecting * ┃ ┃ 神兽保佑,代码无bug * ┃ ┃ * ┃ ┃ * ┃ ┃ * ┃ ┃ * ┃ ┗━━━┓ * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ */ 1234567891011121314151617181920212223/** * ┏┓ ┏┓+ + * ┏┛┻━━━┛┻┓ + + * ┃ ┃ * ┃ ━ ┃ ++ + + + * ████━████ ┃+ * ┃ ┃ + * ┃ ┻ ┃ * ┃ ┃ + + * ┗━┓ ┏━┛ * ┃ ┃ * ┃ ┃ + + + + * ┃ ┃ Code is far away from bug with the animal protecting * ┃ ┃ + 神兽保佑,代码无bug * ┃ ┃ * ┃ ┃ + * ┃ ┗━━━┓ + + * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ + + + + * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛+ + + + */ 程序员之歌1234567891011/** * 江城子 . 程序员之歌 * * 十年生死两茫茫，写程序，到天亮。 * 千行代码，Bug何处藏。 * 纵使上线又怎样，朝令改，夕断肠。 * * 领导每天新想法，天天改，日日忙。 * 相顾无言，惟有泪千行。 * 每晚灯火阑珊处，夜难寐，加班狂。*/ 其他好玩的图片1234567891011121314151617/********************************************************************** .--, .--, ( ( \.---./ ) ) '.__/o o\__.' &#123;= ^ =&#125; &gt; - &lt; / \ // \\ //| . |\\ "'\ /'"_.-~^`'-. \ _ /--' ` ___)( )(___ (((__) (__))) 高山仰止,景行行止.虽不能至,心向往之。**********************************************************************/ 1234567891011121314151617181920212223242526272829303132333435/********************************************************************** :: :;J7, :, ::;7: ,ivYi, , ;LLLFS: :iv7Yi :7ri;j5PL ,:ivYLvr ,ivrrirrY2X, :;r@Wwz.7r: :ivu@kexianli. :iL7::,:::iiirii:ii;::::,,irvF7rvvLujL7ur ri::,:,::i:iiiiiii:i:irrv177JX7rYXqZEkvv17 ;i:, , ::::iirrririi:i:::iiir2XXvii;L8OGJr71i :,, ,,: ,::ir@mingyi.irii:i:::j1jri7ZBOS7ivv, ,::, ::rv77iiiriii:iii:i::,rvLq@huhao.Li ,, ,, ,:ir7ir::,:::i;ir:::i:i::rSGGYri712: ::: ,v7r:: ::rrv77:, ,, ,:i7rrii:::::, ir7ri7Lri , 2OBBOi,iiir;r:: ,irriiii::,, ,iv7Luur: ,, i78MBBi,:,:::,:, :7FSL: ,iriii:::i::,,:rLqXv:: : iuMMP: :,:::,:ii;2GY7OBB0viiii:i:iii:i:::iJqL;:: , ::::i ,,,,, ::LuBBu BBBBBErii:i:i:i:i:i:i:r77ii , : , ,,:::rruBZ1MBBqi, :,,,:::,::::::iiriri: , ,,,,::::i: @arqiao. ,:,, ,:::ii;i7: :, rjujLYLi ,,:::::,:::::::::,, ,:i,:,,,,,::i:iii :: BBBBBBBBB0, ,,::: , ,:::::: , ,,,, ,,::::::: i, , ,8BMMBBBBBBi ,,:,, ,,, , , , , , :,::ii::i:: : iZMOMOMBBM2::::::::::,,,, ,,,,,,:,,,::::i:irr:i:::, i ,,:;u0MBMOG1L:::i:::::: ,,,::, ,,, ::::::i:i:iirii:i:i: : ,iuUuuXUkFu7i:iii:i:::, :,:,: ::::::::i:i:::::iirr7iiri:: : :rk@Yizero.i:::::, ,:ii:::::::i:::::i::,::::iirrriiiri::, : 5BMBBBBBBSr:,::rv2kuii:::iii::,:i:,, , ,,:,:i@petermu., , :r50EZ8MBBBBGOBBBZP7::::i::,:::::,: :,:,::i;rrririiii:: :jujYY7LS0ujJL7r::,::i::,::::::::::::::iirirrrrrrr:ii: ,: :@kevensun.:,:,,,::::i:i:::::,,::::::iir;ii;7v77;ii;i, ,,, ,,:,::::::i:iiiii:i::::,, ::::iiiir@xingjief.r;7:i, , , ,,,:,,::::::::iiiiiiiiii:,:,:::::::::iiir;ri7vL77rrirri:: :,, , ::::::::i:::i:::i:i::,,,,,:,::i:i:::iir;@Secbone.ii:::**********************************************************************/ 12345678910111213141516/** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ */ 123456789101112131415161718192021222324/* ************************************************************** * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * | ______ | * * | .-" "-. | * * | / \ | * * | _ | | _ | * * | ( \ |, .-. .-. ,| / ) | * * | &gt; "=._ | )(__/ \__)( | _.=" &lt; | * * | (_/"=._"=._ |/ /\ \| _.="_.="\_) | * * | "=._"(_ ^^ _)"_.=" | * * | "=\__|IIIIII|__/=" | * * | _.="| \IIIIII/ |"=._ | * * | _ _.="_.="\ /"=._"=._ _ | * * | ( \_.="_.=" `--------` "=._"=._/ ) | * * | &gt; _.=" "=._ &lt; | * * | (_/ \_) | * * | | * * '-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=' * * * * LASCIATE OGNI SPERANZA, VOI CH'ENTRATE * ************************************************************** */]]></content>
      <tags>
        <tag>娱乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim操作]]></title>
    <url>%2F2017%2F08%2F25%2Fvim%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[vim的基本操作本人在实验楼学习的时候摘抄下来的，留作自己的笔记。 游标移动按Esc进入普通模式，在该模式下使用方向键或者h,j,k,l键可以移动游标。 按键 说明 h 左 l 右（小写L） j 下 k 上 w 移动到下一个单词 b 移动到上一个单词 进入插入模式在普通模式下使用下面的键将进入插入模式，并可以从相应的位置开始输入 命令 说明 i 在当前光标处进行编辑 I 在行首插入 A 在行末插入 a 在光标后插入编辑 o 在当前行后插入一个新行 O 在当前行前插入一个新行 cw 替换从光标所在位置后到一个单词结尾的字符 命令行模式下保存文档从普通模式输入:进入命令行模式，输入w回车，保存文档。输入:w 文件名可以将文档另存为其他文件名或存到其它路径下 命令行模式下退出vim从普通模式输入:进入命令行模式，输入wq回车，保存并退出编辑 以下为其它几种退出方式： 命令 说明 :q! 强制退出，不保存 :q 退出 :wq! 强制保存并退出 :w &lt;文件路径&gt; 另存为 :saveas 文件路径 另存为 :x 保存并退出 :wq 保存并退出 普通模式下退出vim普通模式下输入Shift+zz即可保存退出vim 普通模式下删除vim文本信息进入普通模式，使用下列命令可以进行文本快速删除： 命令 说明 x 删除游标所在的字符 X 删除游标所在前一个字符 Delete 同x dd 删除整行 dw 删除一个单词（不适用中文） d$或D 删除至行尾 d^ 删除至行首 dG 删除到文档结尾处 d1G 删至文档首部 除此之外，你还可以在命令之前加上数字，表示一次删除多行，如：2dd表示一次删除2行i 重复执行上次命令在普通模式下.(小数点)表示重复上一次的命令操作 执行指定次数相同的命令进入普通模式输入N，N表示重复后面的次数 例如：输入10x，删除10个连续字符 输入3dd，将会删除3行文本 在普通模式下，你还可以使用dw或者daw(delete a word)删除一个单词，所以你可以很容易的联想到dnw(n替换为相应数字)表示删除n个单词 游标的快速跳转普通模式下，下列命令可以让光标快速调转到指定位置，我们分别讨论快速实现行间跳转和行内跳转 行间跳转 命令 说明 nG(n Shift+g) 游标移动到第 n 行(如果默认没有显示行号，请先进入命令模式，输入:set nu以显示行号) gg 游标移动到到第一行 G(Shift+g) 到最后一行 小技巧：你在完成依次跳转后，可以使用Ctrl+o快速回到上一次(跳转前)光标所在位置,这个技巧很实用，比如当你在写代码时，忽然想起有个bug，需要修改，这时候你跳过去改好了，只需要按下Ctrl+o就可以回到你之前的位置。vim中会用很多类似的小技巧就等着你去发掘。 行内跳转普通模式下使用下列命令在行内按照单词为单位进行跳转 命令 说明 w 到下一个单词的开头 e 到下一个单词的结尾 b 到前一个单词的开头 ge 到前一个单词的结尾 0或^ 到行头 $ 到行尾 f&lt;字母&gt; 向后搜索&lt;字母&gt;并跳转到第一个匹配的位置(非常实用) F&lt;字母&gt; 向前搜索&lt;字母&gt;并跳转到第一个匹配的位置 t&lt;字母&gt; 向后搜索&lt;字母&gt;并跳转到第一个匹配位置之前的一个字母(不常用) T&lt;字母&gt; 向前搜索&lt;字母&gt;并跳转到第一个匹配位置之后的一个字母(不常用) 复制粘贴和剪切复制及粘贴文本 ● 普通模式中使用y复制 ○ 普通模式中，yy复制游标所在的整行（3yy表示复制3行） ○ 普通模式中，y^ 复制至行首，或y0。不含光标所在处字符。 ○ 普通模式中，y$ 复制至行尾。含光标所在处字符。 ○ 普通模式中，yw 复制一个单词。 ○ 普通模式中，y2w 复制两个单词。 ○ 普通模式中，yG 复制至文本末。 ○ 普通模式中，y1G 复制至文本开头。 ● 普通模式中使用p粘贴 ○ 普通模式中，p(小写)代表粘贴至光标后（下） ○ 普通模式中，P(大写)代表粘贴至光标前（上） 剪切及粘贴其实前面讲得dd删除命令就是剪切，你每次dd删除文档内容后，便可以使用p来粘贴，也这一点可以让我们实现一个很爽快的功能——交换上下行 字符的替换及撤销(Undo操作)替换和撤销(Undo)命令替换和Undo命令都是针对普通模式下的操作 命令 说明 r+&lt;待替换字母&gt; 将游标所在字母替换为指定字母 R 连续替换，直到按下Esc cc 替换整行，即删除游标所在行，并进入插入模式 cw 替换一个单词，即删除一个单词，并进入插入模式 C(大写) 替换游标以后至行末~反转游标所在字母大小写 u{n} 撤销一次或n次操作 U(大写) 撤销当前行的所有修改 Ctrl+r redo，即撤销undo的操作 快速缩进使用命令进行快速调整缩进操作 ● 普通模式下输入15G，跳转到15行 ● 普通模式下输入&gt;&gt; 整行将向右缩进（使用，用于格式化代码超爽） ● 普通模式下输入&lt;&lt; 整行向左回退 ● 普通模式下输入:进入命令行模式下对shiftwidth值进行设置可以控制缩进和回退的字符数 shiftwidth命令shiftwidth命令是指上一节&gt;&gt;命令产生的缩进（可以简写成sw） 普通模式下输入:进入命令行模式下对shiftwidth值进行设置可以控制缩进和回退的字符数 获取目前的设定值 :set shiftwidth? 设置缩进为10个字符 :set shiftwidth=10 输入ESC回到普通模式，再次尝试&gt;&gt;看缩进量是否变化 调整文本位置命令行模式下输入:ce(center)命令使本行内容居中 :ce 命令行模式下输入:ri(right)命令使本行文本靠右 :ri 命令行模式下输入:le(left)命令使本行内容靠左 :le 查找快速查找普通模式下输入/然后键入需要查找的字符串 按回车后就会进行查找。 ？与/功能相同，只不过？是向上而/是向下查找。 进入查找之后，输入n和N可以继续查找 n表示继续查找，N反向查找 高级查找● 普通模式下输入\*寻找游标所在处的单词 ● 普通模式下输入\#同上，但 \# 是向前（上）找，\*则是向后（下）找 ● 普通模式下输入g\*同\* ，但部分符合该单词即可 ● 普通模式下输入g\#同\# ，但部分符合该单词即可 以上查找n,N 的继续查找命令依然可以用 多文件编辑使用vim编辑多个文件编辑多个文件有两种形式，一种是在进入vim前使用的参数就是多个文件。另一种就是进入vim后再编辑其他的文件。同时创建两个新文件并编辑 $ vim 1.txt 2.txt 默认进入1.txt文件的编辑界面12● 命令行模式下输入:n编辑2.txt文件，可以加!即:n!强制切换，之前一个文件的输入没有保存，仅仅切换到另一个文件● 命令行模式下输入:N编辑1.txt文件，可以加!即:N!强制切换，之前文件内的输入没有保存，仅仅是切换到另一个文件 进入vim后打开新文件12345678● 命令行模式下输入:e 3.txt 打开新文件3.txt● 命令行模式下输入:e# 回到前一个文件● 命令行模式下输入:ls可以列出以前编辑过的文档● 命令行模式下输入:b 2.txt（或者编号）可以直接进入文件2.txt编辑● 命令行模式下输入:bd 2.txt（或者编号）可以删除以前编辑过的列表中的文件项目● 命令行模式下输入:e! 4.txt，新打开文件4.txt，放弃正在编辑的文件● 命令行模式下输入:f 显示正在编辑的文件名● 命令行模式下输入:f new.txt，改变正在编辑的文件名字为new.txt 恢复文件如果因为断电等原因造成文档没有保存，可以采用恢复方式，vim -r进入文档后，输入:ewcover 1.txt来恢复 $ vim -r 1.txt 可视模式可视模式命令简介12345● 在普通模式下输入v（小写），进入字符选择模式，就可以移动光标，光标走过的地方就会选取。再次按下v会后就会取消选取。 ● 在普通模式下输入Shift+v（小写），进入行选择模式，按下V之后就会把整行选取，您可以上下移动光标选更多的行，同样，再按一次Shift+v就可以取消选取。● 在普通模式下输入 Ctrl+v（小写），这是区域选择模式，可以进行矩形区域选择，再按一次Ctrl+v取消选取。● 在可视模式下输入d删除选取区域内容● 在可视模式下输入y复制选取区域内容 视窗操作视窗操作简介vim可以在一个界面里打开多个窗口进行编辑，这些编辑窗口称为vim的视窗。 打开方法有很多种，例如可以使用在命令行模式下输入:new 打开一个新的vim视窗，并进入视窗编辑一个新文件（普通模式下输入Ctrl+w也可以,但是Ctrl+w在chrome下会与chrome关闭标签页的快捷键冲突，所以使用该快捷键你可以在IE或其它浏览器进行练习），除了:new命令，下述列举的多种方法也可以在命令模式或普通模式下打开新的视窗：12345678910111213141516● 命令行模式下输入:sp 1.txt 打开新的水平分屏视窗来编辑1.txt● 命令行模式下输入:vsp 2.txt 打开新的垂直分屏视窗来编辑2.txt● 普通模式下Ctrl-w s 将当前窗口分割成两个水平的窗口● 普通模式下Ctrl-w v 将当前窗口分割成两个垂直的窗口● 普通模式下Ctrl-w q 即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q!● 普通模式下Ctrl-w o 打开一个视窗并且隐藏之前的所有视窗● 普通模式下Ctrl-w j 移至下面视窗● 普通模式下Ctrl-w k 移至上面视窗● 普通模式下Ctrl-w h 移至左边视窗● 普通模式下Ctrl-w l 移至右边视窗● 普通模式下Ctrl-w J 将当前视窗移至下面● 普通模式下Ctrl-w K 将当前视窗移至上面● 普通模式下Ctrl-w H 将当前视窗移至左边● 普通模式下Ctrl-w L 将当前视窗移至右边● 普通模式下Ctrl-w - 减小视窗的高度● 普通模式下Ctrl-w + 增加视窗的高度 文档加密创建加密文档$ vim -x file1 输入您的密码 确认密码 这样在下一次打开时，vim就会要求你输入密码 在vim执行外部命令在命令行模式中输入!可以执行外部的shell命令123● :!ls 用于显示当前目录的内容● :!rm FILENAME用于删除名为 FILENAME 的文件● :w FILENAME可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件 帮助系统vim中的查看帮助123● 普通模式下按F1打开vim自己预设的帮助文档● 命令行模式下输入:h shiftwidth 打开名为shiftwidth的帮助文件● 命令行模式下输入:ver 显示版本及参数 功能设定vim的功能设定可以在编辑文件的时候进行功能设定，如命令行模式下输入:set nu（显示行数），设定值退出vim后不会保存。要永久保存配置需要修改vim配置文件。 vim的配置文件~/.vimrc(实验楼环境中配置文件在/etc/vim/vimrc)，可以打开文件进行修改，不过务必小心不要影响vim正常使用 获取目前的设定1234● 命令行模式下输入:set或者:se显示所有修改过的配置● 命令行模式下输入:set all 显示所有的设定值● 命令行模式下输入:set option? 显示option的设定值● 命令行模式下输入:set nooption 取消当期设定值 set功能的说明12345● 命令行模式下输入:set autoindent(ai) 设置自动缩进● 命令行模式下输入:set autowrite(aw) 设置自动存档，默认未打开● 命令行模式下输入:set background=dark或light，设置背景风格● 命令行模式下输入:set backup(bk) 设置自动备份，默认未打开● 命令行模式下输入: set cindent(cin) 设置C语言风格缩进]]></content>
      <tags>
        <tag>ubuntu基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器安装问题补充（安装时Select and install software失败）]]></title>
    <url>%2F2017%2F08%2F25%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[服务器安装问题补充之前写好的服务器安装教程已经写好了，针对与大部分服务器的安装应该都可以正常安装了，但是近期安装实验室服务器的时候遇到了问题。安装时Select and install software失败，这个问题在以前没有遇到过，不过也有可能时启动盘做的有问题吧，不过是刚从ubuntu官网上下载的系统做的启动盘，有点迷，不过先记录一下好了。 解决方案先跳过该步骤根据系统的提示遇到这个步骤的时候我们可以选择重新再来一次，也可以直接跳过该步骤，这个地方我尝试过，就算你重新再来几次也是这样的。当然如果你选择重新安装系统，如果没有换系统盘的话还是这样的，换了以后我也不确定的。 所以再此我选择跳过此步骤，直接开始下面的安装，最后安装完成，重启完成 跳过后的问题及解决方案问题描述跳过上面的步骤以后我们发现我们可以正常的进入系统。但是呢，在这个时候我们开始安装一些必要的软件的时候，我们会发现根本找不到安装包的，并且在输入的时候也不能补全命令。 问题解决无法找到安装包这个时候我们可以发现其实是因为我们apt的源有问题，当然开始的时候它也会让你找CD的路径来进行安装，虽然应该可以通过外接CD或者硬盘然后通过路径来安装，不过这样很是麻烦，所以我们必须要修复它。 这个时候我们可以去更新apt的源，这里建议使用清华的源，比较方便比较快。清华源的网站：https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/ 具体操作（因为没有安装vim呢，所以这里我们只能使用vi或者nano来进行文件系统的改写） 1sudo vi /etc/apt/sources.list 然后可以把里面的东西都删除掉或者使用“#”都注释掉下面开始往里面方源了，vi的操作跟vim的操作是一样的 下面是我填写的源，可以照着填：12345678910deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricteddeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricteddeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricteddeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security multiverse 无法自动补全命令为了提高我们的效率我们一般会用Tab键进行补全的，这个时候我在进行安装的时候install并不能自动补全，所以我进行如下操作： 1sudo apt install bash-completion 然后重启就可以了，问题解决。 服务器的远程配置正常安装ubuntu系统的时候在出错的这一步我们其实是可以选择打开ssh远程登陆的，但是此时系统安装这一步出错了，我们应该怎么打开ssh远程登陆的，毕竟对于服务器我们不能每个人都坐在服务器前面插个显示器来用。 首先安装sshsudo apt-get install openssh-server 理论上来说安装了ssh以后服务器的ssh会自动打开的，如果不放心可以查看一下 ps -e |grep ssh 如果看到sshd那说明ssh-server已经启动了。如果没有则可以这样启动： 1sudo /etc/init.d/ssh start 或者1service ssh start ssh-server配置文件位于/etc/ssh/sshd_config，在这里可以定义SSH的服务端口，默认端口是22，你可以自己定义成其他端口号然后重启SSH服务：12sudo /etc/init.d/ssh stopsudo /etc/init.d/ssh start 禁用root登陆其实这个也可以不禁用的，但是为了安全，我们一般都是禁用root直接远程登陆的。禁用的方法：修改/etc/ssh/ssh_config文件将其中的PermitRootLogin改成no就可以了，不过如果配置文件中没有这个的话，也可以直接手动输入。然后重启ssh服务就可以了 /etc/rc.d/sshd restart 当然如果为了安全的话，其实我们可以直接禁用掉密码登陆，采取用密钥登陆的方式，这样更安全。因为其实你的密码很容易被别人截获的，这个可以参看之前的博客进行设置。另外补充一句：其实咱们使用的账户及密码等信息保存在 /etc/passwd 以及 /etc/shadow 中，密码采用crypt（）算法加密保存了而已。]]></content>
      <tags>
        <tag>手把手教你配置Ubuntu server服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言编写程序计时]]></title>
    <url>%2F2017%2F08%2F22%2FC%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[C语言编写程序计时在我们编程的时候，有时候需要我们去监测程序运行的时间问题，尤其是在做加速或者做优化的时候，一个程序运行的时间也许就是我们判断程序好坏的标准，所以我们有时候要进行计时。（因为用到了，所以做个记录方便下次查看） 在windows上进行计时123456789101112131415161718#include "stdio.h"#include "time.h"clock_t start_time, finish_time;/*计时*/double cord_time;/*计时*/int main(int argc, char* argv[])&#123; start_time = clock();/*****************************计时开始***********************************/ /*******************/ /*这里编写程序*/ /*******************/ finish_time = clock();/***************************计时结束***********************************/ //显示总的用时 cord_time = (double)(finish_time - start_time) ; printf("time=%f ms\n", cord_time); return 0;&#125; 在linux上进行计时123456789101112131415161718192021222324252627282930313233#include "stdio.h"#include &lt;sys/time.h&gt;int time_substract(struct timeval *result, struct timeval *begin,struct timeval *end)&#123; if(begin-&gt;tv_sec &gt; end-&gt;tv_sec) return -1; if((begin-&gt;tv_sec == end-&gt;tv_sec) &amp;&amp; (begin-&gt;tv_usec &gt; end-&gt;tv_usec)) return -2; result-&gt;tv_sec = (end-&gt;tv_sec - begin-&gt;tv_sec); result-&gt;tv_usec = (end-&gt;tv_usec - begin-&gt;tv_usec); if(result-&gt;tv_usec &lt; 0) &#123; result-&gt;tv_sec--; result-&gt;tv_usec += 1000000; &#125; return 0;&#125;int main(int argc, char* argv[])&#123; struct timeval start,stop,diff; memset(&amp;start,0,sizeof(struct timeval)); memset(&amp;stop,0,sizeof(struct timeval)); memset(&amp;diff,0,sizeof(struct timeval)); gettimeofday(&amp;start,0); /*******************/ /*这里编写程序*/ /*******************/ gettimeofday(&amp;stop,0); time_substract(&amp;diff,&amp;start,&amp;stop); printf("Total time : %d s,%d us\n",(int)diff.tv_sec,(int)diff.tv_usec); return 0;&#125;]]></content>
      <tags>
        <tag>常用的C语言小程序代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 语言TXT文件的读写]]></title>
    <url>%2F2017%2F08%2F22%2FC-%E8%AF%AD%E8%A8%80TXT%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[C语言编写TXT文件的读写本问针对的是对txt文件中数据的读写操作（非二进制的，二进制的可能后面会补充）,因为用到做个记录。 C语言编写TXT文件的读12345678910111213141516171819void Read_file(double **Matrix, char *FileName, int height, int wide)&#123; FILE *fp = fopen(FileName, "r"); if (!fp) &#123; printf("can't open file\n"); &#125; else &#123; for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; wide; j++) &#123; fscanf(fp, "%lf", &amp;Matrix[i][j]); &#125; &#125; &#125; fclose(fp);&#125; C语言编写TXT文件的写1234567891011121314151617FILE *fp = fopen(output, "w+");if (!fp)&#123; printf("can't open file\n");&#125;else&#123; for (int i = 0; i &lt; FC_height; i++) &#123; for (int j = 0; j &lt; FC_wide; j++) &#123; fprintf(fp, "%lf\t", FC_matrix[i][j]); &#125; fprintf(fp, "\n"); &#125;&#125; fclose(fp);]]></content>
      <tags>
        <tag>常用的C语言小程序代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件脚本编写问题]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E9%97%AE%E9%A2%98-by%E9%BB%84%E6%B5%B7%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[文件脚本编写问题在编写脚本的时候我们可能会遇到一些各种各样的小问题，比如放置位置，以及使用权限等。 文件脚本编写好以后可以直接放置到 /usr/local/sbin 目录下面，这样就可以不用去申请环境变量了，使用起来也就比较方便了。 chmod a+x [文件名] 付给权限]]></content>
      <tags>
        <tag>Hadoop脚本编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清理集群的脚本]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%B8%85%E7%90%86%E9%9B%86%E7%BE%A4%E7%9A%84%E8%84%9A%E6%9C%AC-by%E9%BB%84%E6%B5%B7%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[清理集群的脚本该脚本旨在重新配置hadoop的时候我们需要清理一下集群中的东西，比如记录等。 clear.sh源代码例子123456#!/bin/bashstop-all.shxrm.sh /tmp/hadoopxrm.sh /hadoop/logsecho "clean done!"(主要为了清除tmp下面的文件hadoop还有logs)]]></content>
      <tags>
        <tag>Hadoop脚本编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始化集群]]></title>
    <url>%2F2017%2F08%2F17%2F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%86%E7%BE%A4-by%E9%BB%84%E6%B5%B7%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[初始化集群该脚本主要时对第一次使用集群的时候进行一个初始化。 init.sh源代码例子123#!/bin/bash hdfs namenode -formatstart-all.sh 或者12start-dfs.shstart-yarn.sh 创建目录1./bin/hdfs dfs -mkdir -p /user/hadoop 查看显示目录1hadoop fs –ls -R /]]></content>
      <tags>
        <tag>Hadoop脚本编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所有节点 文件删除脚本编写]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9-%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99-by%E9%BB%84%E6%B5%B7%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[所有节点 文件删除脚本编写该脚本旨在删除所有节点上相同的东西，比如hadoop的重新配置等，还有删除hadoop的log等文件，都比较方便。 xrm.sh的源代码例子12345678910111213141516171819202122232425#!/bin/bashif [ $# -lt 1 ] ; thenecho no argsexit;fi#get first argumentarg1=$1;cuser=`whoami`fname=`basename $arg1`dir=`dirname $arg1`if [ $dir == "." ] ; thendir=`pwd`# echo $dirfiecho -----------------rming $arg1 from localhost-------------;rm -rf $arg1echofor (( i=200;i&lt;=500;i=i+100)) ;doecho ---------------rming $arg1 from s$i -------------;ssh s$i rm -rf $dir/$fnameechodone]]></content>
      <tags>
        <tag>Hadoop脚本编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所有节点 文件拷贝脚本编写]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9-%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99-by%E9%BB%84%E6%B5%B7%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[所有节点 文件拷贝脚本编写该脚本旨在往每个节点拷贝数据，之前我们的拷贝是需要自己一个节点一个节点链接然后拷贝，但是如果我们每个节点都拷贝同样的数据时，这样做显然很麻烦，如果节点多的话还很浪费时间，这样我们就可以通过该脚本自己循环拷贝。 xcp.sh源代码例子12345678910111213141516171819202122232425#!/bin/bashif [ $# -lt 1 ] ; thenecho no argsexit;fi#get first argumentarg1=$1;cuser=`whoami`fname=`basename $arg1`dir=`dirname $arg1`if [ $dir == "." ] ; thendir=`pwd`# echo $dirfifor (( i=200;i&lt;=500;i=i+100)) ;doecho -----------coping $arg1 to $i------------------;if [ -d $arg1 ] ; thenscp -r $arg1 $cuser@s$i:$direlsescp $arg1 $cuser@s$i:$dirfiechodone]]></content>
      <tags>
        <tag>Hadoop脚本编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所有节点执行同一指令的操作]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E6%89%A7%E8%A1%8C%E5%90%8C%E4%B8%80%E6%8C%87%E4%BB%A4%E7%9A%84%E6%93%8D%E4%BD%9C-by%E9%BB%84%E6%B5%B7%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[所有节点执行同一指令的操作该脚本旨在对每个节点都执行同一个指令，这样就不用每次都shell到每个子节点上去执行了，较为方便。 xcall.sh的源代码例子123456789101112131415#!/bin/bashif [ $# -lt 1 ] ; thenecho no argsexit;fiecho -----------------xcall $arg1 from localhost-----------------$@echo#get first argumentfor (( i=0;i&lt;=3;i=i+1));do echo --------------------xcall $arg1 from Slave$i ------------------;ssh Slave$i $@echodone]]></content>
      <tags>
        <tag>Hadoop脚本编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所有节点 文件查看脚本编写]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9-%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[所有节点 文件查看脚本编写该脚本用于一次查看所有集群节点相同位置下的文件，类似于手动在每个节点上输入ls指令进行查看。 xls.sh的源代码例子12345678910111213141516171819202122#!/bin/bashif [ $# -lt 1 ] ; thenecho no argsexit;fi#get first argumentarg1=$1;cuser=`whoami`fname=`basename $arg1`dir=`dirname $arg1`if [ $dir == "." ] ; thendir=`pwd`# echo $dirfifor (( i=200;i&lt;=500;i=i+100)) ;doecho ---------------ls $arg1 from s$i -------------;ssh s$i ls $dir/$fname | xargsechodone]]></content>
      <tags>
        <tag>Hadoop脚本编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展Slave的时候需要注意的一些问题]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%89%A9%E5%B1%95Slave%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[扩展Slave的时候需要注意的一些问题 扩展的时候可以先直接按照Hadoop集群安装配置教程先进行。 这里需要更改 /usr/local/hadoop/etc/hadoop 路径下的 slave文件中的参数，需要把添加的节点加进去。 并且在Master里面的 /etc/hosts 中添加新加节点的IP和节点的命名。（如果想用节点的命名来连接任意一台节点计算机的话，我们需要把这个操作在每台节点计算机上进行） 如果存在改变节点名字的操作，在文件scp传输的时候可能会有错误，但是在警告中下面的语句有提示让移除之前命名和IP的对应关系，复制下来直接操作就可以了，然后在接着使用scp进行文件传输就没有什么问题了。]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop安装_单机伪分布式配置]]></title>
    <url>%2F2017%2F08%2F16%2FHadoop%E5%AE%89%E8%A3%85_%E5%8D%95%E6%9C%BA%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Hadoop安装_单机伪分布式配置创建hadoop账户添加用户： sudo useradd -m hadoop -s /bin/bash 给用户设置密码： sudo passwd hadoop 给用户管理员权限： sudo adduser hadoop sudo 更新apt sudo apt-get update 安装vim: sudo apt-get install vim 安装SSH、配置SSH无密码登陆sudo apt-get install openssh-server ssh localhost exit # 退出刚才的 ssh localhost cd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhost ssh-keygen -t rsa # 会有提示，都按回车就可以 cat ./id_rsa.pub &gt;&gt; ./authorized_keys # 加入授权 此时再 ssh localhost 时就可以无密码访问了。 安装Java环境sudo apt-get install openjdk-8-jre openjdk-8-jdk dpkg -L openjdk-8-jdk | grep &#39;/bin/javac&#39; vim ~/.bashrc export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 source ~/.bashrc # 使变量设置生效 检查是否正确： echo $JAVA_HOME # 检验变量值 java -version $JAVA_HOME/bin/java -version # 与直接执行 java -version 一样 如果设置正确的话，$JAVA_HOME/bin/java -version 会输出 java 的版本信息，且和 java -version 的输出结果一样 安装 Hadoop 2Hadoop 2 可以通过 http://mirror.bit.edu.cn/apache/hadoop/common/ 或者 http://mirrors.cnnic.cn/apache/hadoop/common/ 下载，一般选择下载最新的稳定版本，即下载 “stable” 下的 hadoop-2.x.y.tar.gz 这个格式的文件，这是编译好的，另一个包含 src 的则是 Hadoop 源代码，需要进行编译才可使用。 我们选择将 Hadoop 安装至 /usr/local/ 中： sudo tar -zxf ~/下载/hadoop-2.7.3.tar.gz -C /usr/local # 解压到/usr/local中 cd /usr/local/ sudo mv ./hadoop-2.7.3/ ./hadoop # 将文件夹名改为hadoop sudo chown -R hadoop ./hadoop # 修改文件权限 Hadoop 解压后即可使用。输入如下命令来检查 Hadoop 是否可用，成功则会显示 Hadoop 版本信息： cd /usr/local/hadoop ./bin/hadoop version Hadoop单机配置(非分布式)【这一步个人认为可以用来检测hadoop是否安装成功，可以不用管的】 cd /usr/local/hadoop mkdir ./input cp ./etc/hadoop/*.xml ./input # 将配置文件作为输入文件 ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep ./input ./output &#39;dfs[a-z.]+&#39; （和上面一行连着的） cat ./output/* # 查看运行结果 rm -r ./output Hadoop伪分布式配置Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode，同时，读取的是 HDFS 中的文件。 Hadoop 的配置文件位于 /usr/local/hadoop/etc/hadoop/ 中，伪分布式需要修改2个配置文件 core-site.xml 和 hdfs-site.xml 。Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。 修改配置文件 core-site.xml (通过 vim 编辑会比较方便: vim ./etc/hadoop/core-site.xml)，将当中的1234567891011121314&lt;configuration&gt;&lt;/configuration&gt;修改为下面配置：&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 同样的，修改配置文件 hdfs-site.xml：1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 配置完成后，执行 NameNode 的格式化:成功的话，会看到 “successfully formatted” 和 “Exitting with status 0” 的提示，若为 “Exitting with status 1” 则是出错。 接着开启 NameNode 和 DataNode 守护进程。 ./sbin/start-dfs.sh 输入yes（可能第一次需要）启动完成后，可以通过命令 jps 来判断是否成功启动，若成功启动则会列出如下进程: “NameNode”、”DataNode” 和 “SecondaryNameNode”（如果 SecondaryNameNode 没有启动，请运行 sbin/stop-dfs.sh 关闭进程，然后再次尝试启动尝试）。如果没有 NameNode 或 DataNode ，那就是配置不成功，请仔细检查之前步骤，或通过查看启动日志排查原因。成功启动后，可以访问 Web 界面 http://localhost:50070/ 查看 NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。 运行Hadoop伪分布式实例（配置时其实也可以不用管，它只是跑了一个例子） 上面的单机模式，grep 例子读取的是本地数据，伪分布式读取的则是 HDFS 上的数据。要使用 HDFS，首先需要在 HDFS 中创建用户目录： ./bin/hdfs dfs -mkdir -p /user/hadoop 接着将 ./etc/hadoop 中的 xml 文件作为输入文件复制到分布式文件系统中，即将 /usr/local/hadoop/etc/hadoop 复制到分布式文件系统中的 /user/hadoop/input 中。我们使用的是 hadoop 用户，并且已创建相应的用户目录 /user/hadoop ，因此在命令中就可以使用相对路径如 input，其对应的绝对路径就是 /user/hadoop/input: ./bin/hdfs dfs -mkdir input ./bin/hdfs dfs -put ./etc/hadoop/*.xml input 复制完成后，可以通过如下命令查看文件列表： ./bin/hdfs dfs -ls input 伪分布式运行 MapReduce 作业的方式跟单机模式相同，区别在于伪分布式读取的是HDFS中的文件（可以将单机步骤中创建的本地 input 文件夹，输出结果 output 文件夹都删掉来验证这一点）。 ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep input output &#39;dfs[a-z.]+&#39; 查看运行结果的命令（查看的是位于 HDFS 中的输出结果）： ./bin/hdfs dfs -cat output/* 我们也可以将运行结果取回到本地： rm -r ./output # 先删除本地的 output 文件夹（如果存在） ./bin/hdfs dfs -get output ./output # 将 HDFS 上的 output 文件夹拷贝到本机 cat ./output/* Hadoop 运行程序时，输出目录不能存在，否则会提示错误 “org.apache.hadoop.mapred.FileAlreadyExistsException: Output directory hdfs://localhost:9000/user/hadoop/output already exists” ，因此若要再次执行，需要执行如下命令删除 output 文件夹: ./bin/hdfs dfs -rm -r output # 删除 output 文件夹 若要关闭 Hadoop，则运行 ./sbin/stop-dfs.sh 启动YARN（伪分布式不启动 YARN 也可以，一般不会影响程序执行） YARN 是从 MapReduce 中分离出来的，负责资源管理与任务调度。YARN 运行于 MapReduce 之上，提供了高可用性、高扩展性 上述通过 ./sbin/start-dfs.sh 启动 Hadoop，仅仅是启动了 MapReduce 环境，我们可以启动 YARN ，让 YARN 来负责资源管理与任务调度。 首先修改配置文件 mapred-site.xml，这边需要先进行重命名： mv ./etc/hadoop/mapred-site.xml.template ./etc/hadoop/mapred-site.xml 然后再进行编辑，同样使用 vim 编辑 vim ./etc/hadoop/mapred-site.xml ：123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 接着修改配置文件 yarn-site.xml：123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 然后就可以启动 YARN 了（需要先执行过 ./sbin/start-dfs.sh）： ./sbin/start-yarn.sh # 启动YARN ./sbin/mr-jobhistory-daemon.sh start historyserver # 开启历史服务器，才能在Web中查看任务运行情况 开启后通过 jps 查看，可以看到多了 NodeManager 和 ResourceManager 两个后台进程启动 YARN 之后，运行实例的方法还是一样的，仅仅是资源管理方式、任务调度不同。观察日志信息可以发现，不启用 YARN 时，是 “mapred.LocalJobRunner” 在跑任务，启用 YARN 之后，是 “mapred.YARNRunner” 在跑任务。启动 YARN 有个好处是可以通过 Web 界面查看任务的运行情况：http://master:8088/cluster， 同样的，关闭 YARN 的脚本如下： ./sbin/stop-yarn.sh ./sbin/mr-jobhistory-daemon.sh stop historyserver 参考资料Hadoop集群安装配置教程_Hadoop2.6.0_Ubuntu/CentOS：http://www.powerxing.com/install-hadoop-cluster/ Hadoop安装教程_单机/伪分布式配置_Hadoop2.6.0/Ubuntu14.04http://www.powerxing.com/install-hadoop/]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop集群安装配置教程]]></title>
    <url>%2F2017%2F08%2F16%2FHadoop%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[hadoop集群安装准备工作Hadoop 集群的安装配置大致为如下流程: 1、选定一台机器作为 Master 2、在 Master 节点上配置 hadoop 用户、安装 SSH server、安装 Java 环境 3、在 Master 节点上安装 Hadoop，并完成配置 4、在其他 Slave 节点上配置 hadoop 用户、安装 SSH server、安装 Java 环境 5、将 Master 节点上的 /usr/local/hadoop 目录复制到其他 Slave 节点上 6、在 Master 节点上开启 Hadoop 创建hadoop账户添加用户： sudo useradd -m hadoop -s /bin/bash 给用户设置密码： sudo passwd hadoop 给用户管理员权限： sudo adduser hadoop sudo 更新aptsudo apt-get update 安装vim: sudo apt-get install vim 安装Java环境sudo apt-get install openjdk-8-jre openjdk-8-jdk dpkg -L openjdk-8-jdk | grep &#39;/bin/javac&#39; vim ~/.bashrc export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 source ~/.bashrc # 使变量设置生效 检查是否正确： echo $JAVA_HOME # 检验变量值 java -version $JAVA_HOME/bin/java -version # 与直接执行 java -version 一样 如果设置正确的话，$JAVA_HOME/bin/java -version 会输出 java 的版本信息，且和 java -version 的输出结果一样 安装 Hadoop 2Hadoop 2 可以通过 http://mirror.bit.edu.cn/apache/hadoop/common/ 或者 http://mirrors.cnnic.cn/apache/hadoop/common/ 下载，一般选择下载最新的稳定版本，即下载 “stable” 下的 hadoop-2.x.y.tar.gz 这个格式的文件，这是编译好的，另一个包含 src 的则是 Hadoop 源代码，需要进行编译才可使用。 我们选择将 Hadoop 安装至 /usr/local/ 中：sudo tar -zxf ~/下载/hadoop-2.7.3.tar.gz -C /usr/local # 解压到/usr/local中 cd /usr/local/ sudo mv ./hadoop-2.7.3/ ./hadoop # 将文件夹名改为hadoop sudo chown -R hadoop ./hadoop # 修改文件权限 Hadoop 解压后即可使用。输入如下命令来检查 Hadoop 是否可用，成功则会显示 Hadoop 版本信息： cd /usr/local/hadoop ./bin/hadoop version 网络配置假设集群所用的节点都位于同一个局域网。 首先在 Master 节点上完成准备工作，并关闭 Hadoop (/usr/local/hadoop/sbin/stop-dfs.sh)，再进行后续集群配置。 为了便于区分，可以修改各个节点的主机名（在终端标题、命令行中可以看到主机名，以便区分）。在 Ubuntu中，我们在 Master 节点上执行如下命令修改主机名（即改为 Master，注意是区分大小写的）： 设置主机名： sudo vim /etc/hostname 设置IP sudo vim /etc/hosts 设置如下： 192.168.1.121 Master 192.168.1.122 Slave1 我们在 /etc/hosts 中将该映射关系填写上去即可，如下图所示（一般该文件中只有一个 127.0.0.1，其对应名为 localhost，如果有多余的应删除，特别是不能有 “127.0.0.1 Master” 这样的记录） 配置好后需要在各个节点上执行如下命令，测试是否相互 ping 得通，如果 ping 不通，后面就无法顺利配置成功：ping Master -c 3 # 只ping 3次，否则要按 Ctrl+c 中断ping Slave1 -c 3 继续下一步配置前，请先完成所有节点的网络配置，修改过主机名的话需重启才能生效。 SSH无密码登陆节点sudo apt-get install openssh-server Master上面操作： 首先生成 Master 节点的公匙，在 Master 节点的终端中执行（因为改过主机名，所以还需要删掉原有的再重新生成一次）： cd ~/.ssh # 如果没有该目录，先执行一次ssh localhost rm ./id_rsa* # 删除之前生成的公匙（如果有） ssh-keygen -t rsa # 一直按回车就可以 让 Master 节点需能无密码 SSH 本机，在 Master 节点上执行： cat ./id_rsa.pub &gt;&gt; ./authorized_keys 完成后可执行 ssh Master 验证一下（可能需要输入 yes，成功后执行 exit 返回原来的终端）。接着在 Master 节点将上公匙传输到 Slave1 节点：（当然多个节点的话，每个节点都要传输） scp ~/.ssh/id_rsa.pub hadoop@Slave1:/home/hadoop/ Slave1上面操作： 接着在 Slave1 节点上，将 ssh 公匙加入授权： mkdir ~/.ssh # 如果不存在该文件夹需先创建，若已存在则忽略 cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys rm ~/id_rsa.pub # 用完就可以删掉了 如果有其他 Slave 节点，也要执行将 Master 公匙传输到 Slave 节点、在 Slave 节点上加入授权这两步。（如果配置好了以后可以用 ssh Slave1 指令检验，发现可以不用密码就可以连接上了） 配置PATH变量在单机伪分布式配置教程的最后，说到可以将 Hadoop 安装目录加入 PATH 变量中，这样就可以在任意目录中直接使用 hadoo、hdfs 等命令了，如果还没有配置的，需要在 Master 节点上进行配置。首先执行 vim ~/.bashrc，加入一行： export PATH=$PATH:/usr/local/hadoop/bin:/usr/local/hadoop/sbin 保存后执行 source ~/.bashrc 使配置生效 配置集群/分布式环境集群/分布式模式需要修改 /usr/local/hadoop/etc/hadoop 中的5个配置文件，更多设置项可点击查看官方说明，这里仅设置了正常启动所必须的设置项： slaves、core-site.xml、hdfs-site.xml、mapred-site.xml、yarn-site.xml 。 1, 文件 slaves，将作为 DataNode 的主机名写入该文件，每行一个，默认为 localhost，所以在伪分布式配置时，节点即作为 NameNode 也作为 DataNode。分布式配置可以保留 localhost，也可以删掉，让 Master 节点仅作为 NameNode 使用。 本教程让 Master 节点仅作为 NameNode 使用，因此将文件中原来的 localhost 删除，只添加一行内容：Slave1。（相应的如果有多个节点要都添加上的） 2, 文件 core-site.xml 改为下面的配置：1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://Master:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt;&lt;/configuration&gt; 3, 文件 hdfs-site.xml，dfs.replication 一般设为 3，但我们只有一个 Slave 节点，所以 dfs.replication 的值还是设为 1：（如果是多个节点还是改为3）【这里的参数我的理解是数据备份多少次】123456789101112131415161718&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;Slave0:50090&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;3&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 4, 文件 mapred-site.xml （可能需要先重命名，默认文件名为 mapred-site.xml.template），然后配置修改如下：1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;Master:10020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;Master:19888&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 5, 文件 yarn-site.xml：12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;Master&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 配置好后，将 Master 上的 /usr/local/Hadoop 文件夹复制到各个节点上。因为之前有跑过伪分布式模式，建议在切换到集群模式前先删除之前的临时文件。 在 Master 节点上执行： cd /usr/local sudo rm -r ./hadoop/tmp # 删除 Hadoop 临时文件 sudo rm -r ./hadoop/logs/* # 删除日志文件 tar -zcf ~/hadoop.master.tar.gz ./hadoop # 先压缩再复制 cd ~ scp ./hadoop.master.tar.gz Slave1:/home/hadoop 在 Slave1 节点上执行：（如果有多个节点每个节点上都要执行一遍） sudo rm -r /usr/local/hadoop # 删掉旧的（如果存在） sudo tar -zxf ~/hadoop.master.tar.gz -C /usr/local sudo chown -R hadoop /usr/local/hadoop （如果启动不成功的话可以删除 /usr/loval 目录下的 logs和 tmp 再重新操作一次）同样，如果有其他 Slave 节点，也要执行将 hadoop.master.tar.gz 传输到 Slave 节点、在 Slave 节点解压文件的操作。 首次启动需要先在 Master 节点执行 NameNode 的格式化： hdfs namenode -format # 首次运行需要执行初始化，之后不需要 接着可以启动 hadoop 了，启动需要在 Master 节点上进行： start-dfs.sh start-yarn.sh mr-jobhistory-daemon.sh start historyserver 也可以在更目录下面执行 start-all.sh mr-jobhistory-daemon.sh start historyserver 通过命令 jps 可以查看各个节点所启动的进程。正确的话，在 Master 节点上可以看到 NameNode、ResourceManager、SecondrryNameNode、JobHistoryServer 进程 在 Slave 节点可以看到 DataNode 和 NodeManager 进程. 缺少任一进程都表示出错。另外还需要在 Master 节点上通过命令 hdfs dfsadmin -report 查看 DataNode 是否正常启动，如果 Live datanodes 不为 0 ，则说明集群启动成功。 也可以通过 Web 页面看到查看 DataNode 和 NameNode 的状态：http://master:50070/。如果不成功，可以通过启动日志排查原因。 同样可以通过 Web 界面查看任务进度 http://master:8088/cluster，在 Web 界面点击 “Tracking UI” 这一列的 History 连接，可以看到任务的运行信息 参考资料Hadoop集群安装配置教程_Hadoop2.6.0_Ubuntu/CentOS：http://www.powerxing.com/install-hadoop-cluster/ Hadoop安装教程_单机/伪分布式配置_Hadoop2.6.0/Ubuntu14.04http://www.powerxing.com/install-hadoop/]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立自己的github博客]]></title>
    <url>%2F2017%2F08%2F15%2F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84github%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[可以根据博客中的hello-world文件中讲述的安装下面是一些详细的步骤1、安装node,可以去node的官网直接下载 https://nodejs.org/en/ （这里我下载的是node-v6.11.1-x64）2、安装hexo，可以打开cmd终端输入 npm install -g hexo-cli 3、安装完hexo后开始在电脑上建立一下自己写博客的文件夹，依旧是在cmd终端中运行 cd C:\Users\Darren\Documents #实际上是进入了电脑的文档文件夹 mkdir blog cd blog hexo init blog cd blog hexo s 然后就可以用 http://localhost:4000/ 来查看博客是否安装成功 npm install hexo-deployer-git --save 4、修改_config.yml这个配置文件 # Site title: Darren subtitle: 海亮的笔记本 description: author: Darren language: zh-Hans timezone: # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: repo是自己在自己github中建立的地址 5、开始部署 hexo d 之后可以去看一下你的博客就好了 https://huanghailiang.github.io/ 到此博客基本搭建完成了，剩下的东西就可以按照自己的兴趣去自己配置了。 如果标签没有的话需要自己新建一个hexo new page tags 里面修改为： --- title: tags date: 2017-08-15 11:06:32 type: tags ---]]></content>
      <tags>
        <tag>搭建自己的github博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习环境搭建------by邵碧尧]]></title>
    <url>%2F2017%2F07%2F23%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[深度学习环境搭建开始接触深度学习一年多时间了，总是有种技术发展飞快，没等你掌握现有技术更牛X的技术又出来了。身处AI浪潮中，到现在越发有种感觉：深度学习可能很多问题都能解决，但我们自己并没有那么多精力去研究那么多方面，自然语言处理，自动驾驶，人脸识别等等，选定一个方向深入研究才是正解。至少目前是这么理解的，不对希望朋友指正！ 如今深度学习的框架很多，Caffe，TensorFlow，Torch等都各有各的优势，开始深度学习不可避免要配置深度学习的工作环境，如果不知道方法也许在开头就会花费很多时间，写这篇博客的目的就是帮助大家更快上手。下面介绍Caffe在Ubuntu 16.04上的搭建过程（Ubuntu 14.04同样可以） CaffeCaffe的环境搭建在几个框架中是最麻烦的，因为Caffe用到的依赖库很多，如果配置GPU版有时候显卡驱动和CUDA也能把你折腾好久。CPU版和GPU版主要差别就是在NVIDIA显卡驱动和CUDA的安装上，其他框架要用到NVIDIA显卡其实差别也就是这样，因此这也算服务器基础。两个版本有区别的地方会注明。 Nvidia driver123456789lspci | grep -i nvidiasudo add-apt-repository ppa:graphics-drivers/ppasudo apt-get updatesudo apt-get install nvidia-352 % 版本自己查询sudo shutdown -r now 重启后用下面命令查看驱动版本 1cat /proc/driver/nvidia/version CUDA到CUDA官网下载CUDA安装文件，选择对应版本 这里有下载deb [local]文件，后面会说runfile [local]的用法，先卖个关子。下载好后cd到存放安装的文件夹，使用一下命令，文件名千万别手输，善用tab键 12345sudo dpkg -i cuda-repo-ubuntu1604*amd64.debsudo apt-get updatesudo apt-get install cuda 安装结束，添加环境变量（如果安装服务器，环境变量在每个用户下都需要添加一次，应该是有更聪明的方法，目前还没有找到） 12345echo &apos;export PATH=/usr/local/cuda/bin:$PATH&apos; &gt;&gt; ~/.bashrcecho &apos;export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH&apos; &gt;&gt; ~/.bashrcsource ~/.bashrc 查看安装CUDA版本 1nvcc -V 显示下图信息说明安装好了 再重启下电脑 1sudo shutdown -r now cuDNN这是深度学习训练过程中的加速算法包，到cuDNN 下载对应的安装包，cd到安装包所在文件夹 123456789tar xvf cudnn*.tgzcd cudasudo cp */*.h /usr/local/cuda/include/sudo cp */libcudnn* /usr/local/cuda/lib64/sudo chmod a+r /usr/local/cuda/lib64/libcudnn* 上面说runfile (local)卖了个关子，可以显卡驱动和CUDA一起安装，属于比较方便的方法，和之前的方法有什么差别目前还不知道 1sudo sh cuda_8.0.61_375.26_linux.run 运行这句命令，接下来根据提示操作就好了结束后按照上面的方法添加环境变量 依赖库安装（CPU版从这里开始）12345678910111213141516171819sudo apt-get updatesudo apt-get upgradesudo apt-get install build-essential cmake g++ gfortran git pkg-config python-dev software-properties-common wgetsudo apt-get autoremovesudo rm -rf /var/lib/apt/lists/*sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compilersudo apt-get install --no-install-recommends libboost-all-devsudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-devsudo apt-get install -y libatlas-base-devsudo apt-get install -y python-pip 下载Caffe123456789cd ~mkdir git //在home下新建一个git文件夹，用来存放那些从github上git下来的文件git clone https://github.com/BVLC/caffe.git //从github上git caffecd caffecp Makefile.config.example Makefile.config 修改Makefile.config 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//如果你不使用GPU的话，就将# CPU_ONLY := 1修改成：CPU_ONLY := 1//若使用cudnn，则将# USE_CUDNN := 1修改成：USE_CUDNN := 1//若使用的opencv版本是3的，则将# OPENCV_VERSION := 3修改为：OPENCV_VERSION := 3//若要使用python来编写layer，则需要将# WITH_PYTHON_LAYER := 1修改为WITH_PYTHON_LAYER := 1//重要的一项将# Whatever else you find you need goes here.下面的INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/includeLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib修改为：INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serialLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/x86_64-linux-gnu /usr/lib/x86_64-linux-gnu/hdf5/serial//这是因为ubuntu16.04的文件包含位置发生了变化，尤其是需要用到的hdf5的位置，所以需要更改这一路径 创建Hdf5文件链接 1234567find . -type f -exec sed -i -e &apos;s^&quot;hdf5.h&quot;^&quot;hdf5/serial/hdf5.h&quot;^g&apos; -e &apos;s^&quot;hdf5_hl.h&quot;^&quot;hdf5/serial/hdf5_hl.h&quot;^g&apos; &apos;&#123;&#125;&apos; \;cd /usr/lib/x86_64-linux-gnusudo ln -s libhdf5_serial.so.10.1.0 libhdf5.sosudo ln -s libhdf5_serial_hl.so.10.0.2 libhdf5_hl.so 执行caffe下python文件夹下的指令 1234567cd pythonfor req in $(cat requirements.txt); do pip install $req; done\\目的是检查caffe所需要的python的库的版本，如果出现红字错误说明版本不满足要求，执行下面语句for req in $(cat requirements.txt); do sudo -H pip install $req --upgrade; done 编辑/usr/local/cuda/include/host_config.h，将其中的第115行 123#error -- unsupported GNU version! gcc versions later than 4.9 are not supported!% 改为//#error -- unsupported GNU version! gcc versions later than 4.9 are not supported! make 各种文件（cd到Caffe文件夹）123456789make all -j8 //j8代表计算机cpu有8个核，因此可以多线程一起make，这样make的速度会快很多。一般常用的还有j4make test -j8make runtest -j8make pycaffe //编译python接口make distribute 到这里搭建完毕]]></content>
      <tags>
        <tag>深度学习环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装远程图形界面x2go------by邵碧尧]]></title>
    <url>%2F2017%2F07%2F23%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%85%8D%E7%BD%AEUbuntu%20server%E6%9C%8D%E5%8A%A1%E5%99%A8_5%2F</url>
    <content type="text"><![CDATA[手把手教你配置Ubuntu server服务器安装远程图形界面x2goUbuntu server 安装完成只有命令行界面，一般的工作在Windows下用 xshell 和 winscp ，一个输命令行，一个进行界面化文件管理，还是挺方便的， 但部分用户还是希望有个图形界面更加方便科研工作开展，这里推荐x2go这个轻量化桌面，安装也比较方便，下面就来介绍。首先在服务器上安装一些必要的软件 123456sudo apt-get install software-properties-commonsudo add-apt-repository ppa:x2go/stablesudo apt-get updatesudo apt-get install x2goserver x2goserver-xsessionsudo apt-get updatesudo apt-get install -y xfce4 xfce4-goodies xubuntu-desktop 很简单，几条命令结束就OK了。结束用 1hostname -I 查看ip，后面在Windows下要用到 然后在 Windows 或者 OS X 下安装一个客户端 x2go client ,安装结束打开会跳出如下窗口 在”Host” 中填写服务器ip“Login”中填写要登录的username“Session type”下拉菜单选择“XFCE”，点击OK结束。 在这里输入密码就可以远程连接服务器，同时拥有图形界面了。 配置服务器系列到这里就结束了，小白我自己也在后面多多积累相关的技巧，有了新的经验再来更新，希望大家支持！]]></content>
      <tags>
        <tag>手把手教你配置Ubuntu server服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[管理服务器用户------by邵碧尧]]></title>
    <url>%2F2017%2F07%2F23%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%85%8D%E7%BD%AEUbuntu%20server%E6%9C%8D%E5%8A%A1%E5%99%A8_4%2F</url>
    <content type="text"><![CDATA[手把手教你配置Ubuntu server服务器管理服务器用户管理服务器用户，一项一项开始说，首先要管理，当然要现有用户咯。添加用户我是用adduser 命令，相当于一个简单的交互过程，命令如下： 1sudo adduser username 然后会让你确定用户名，用户密码这些信息，结束后在/home目录下就有一个对应用户名的文件夹了。管理员添加用户后，用户自己可以通过 1passwd 来更新自己的密码。 哪天可能那个用户惹到root管理员了，管理员要删掉那个用户，怎么操作，非常简单 1userdel username 秒删好吧！所以不要惹管理员 如果想修改用户名有改怎么办，有几种方案 第一种，简单粗暴，按照上面的方法删掉用户重新建 第二种，优雅一点，两条命令搞定 12usermod -l New_Login_Name, -md Home_Directory Old_Login_Name groupmod -n NewName OldName 管理员会给服务器装一些基本的软件，有的用户想装自己需要的软件，但是没有权限怎么办嘞？每次都找管理员也是烦的，因此可以给部分用户 sudo 权限，怎么操作呢？修改/etc/sudoers文件，在 root ALL=(ALL) ALL下方添加要给权限的用户名 12root ALL=(ALL) ALLusername ALL=(ALL) ALL 还有种方法就是直接创建管理者账号 1sudo adduser username sudo 以上就是一些最基本的用户管理指令，刚开始是够用了，到后面反正慢慢积累嘛]]></content>
      <tags>
        <tag>手把手教你配置Ubuntu server服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置服务器网络------by邵碧尧]]></title>
    <url>%2F2017%2F07%2F23%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%85%8D%E7%BD%AEUbuntu%20server%E6%9C%8D%E5%8A%A1%E5%99%A8_3%2F</url>
    <content type="text"><![CDATA[手把手教你配置Ubuntu server服务器设置服务器网络之前两篇讲了服务器系统安装和硬盘挂载，这篇总结下网络设置。具体开始讲之前先说说如何实现其他人可以访问服务器。一种方法是由一个网口出来接路由器，用户都连接到路由器的网络上，不管是通过有线还是WiFi，把用户都归到同一个网络下。另一种方法就比较bug了，像清华大学那样，整个学校有线网和无线的Tsinghua都是同一个网络，所以就不需要路由器了，之前不知道还倒腾了很久。又有人要问了，那如何让外网的人可以访问服务器呢？不好意思，我没有研究过，另一个原因也是担心网络安全的问题，毕竟没有学过相关的知识，所以搭个服务器内部用就完了。如果有大神在这方面比较有研究，我也非常欢迎交流。（邮箱：shaobiyao@gmail.com）说回来，先解决基本问题再说 sudo vim /etc/network/interfaces 修改如下部分： auto eth0（这个名称每台机器不一样，可以通过ifconfig -a查询）iface eth0 inet staticaddress 192.168.0.117 #选用同一个网络下不冲突的ipgateway 192.168.0.1 #gateway and netmask 可以通过查看同一网络下的Windows电脑的信息获得，都一样的netmask 255.255.255.0 sudo vim /etc/resolvconf/resolv.conf.d/base(网上有说修改/etc/resolv.conf的，这个文件修改完会被系统覆盖，等于白改)nameserver XXX.XXX.XXX.XXX #和同一网络中Windows的电脑一样 重启网卡： sudo /etc/init.d/network restart 用ping www.baidu.com测试是否成功]]></content>
      <tags>
        <tag>手把手教你配置Ubuntu server服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器多硬盘挂载------by邵碧尧]]></title>
    <url>%2F2017%2F07%2F23%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%85%8D%E7%BD%AEUbuntu%20server%E6%9C%8D%E5%8A%A1%E5%99%A8_2%2F</url>
    <content type="text"><![CDATA[手把手教你配置Ubuntu server服务器服务器多硬盘挂载现在科研中需要处理的数据量经常性会非常大，因此服务器基本都会采用固态硬盘加机械硬盘的解决方案来实现服务器性能和成本的平衡，系统装在固态中，用户数据和数据集存放在机械硬盘中。接下来就讲下如何挂载硬盘 参考网页： http://zwkufo.blog.163.com/blog/static/258825120141283942244/http://www.jianshu.com/p/5c12289dbcd1sudo fdisk –lu (查看当前硬盘及分区情况) 可以看到类似界面 列表中我们可以看到所有硬盘，找到要挂载的硬盘名称，例如/dev/sdb sudo fdisk /dev/sdb(这里为想要挂载的硬盘名称)，利用该命令可以对硬盘进行分区，具体可以参考网页1中的讲解更加详细 sudo mkfs –t ext4 /dev/sdb(硬盘格式化，-t ext4 表示将分区格式化成ext4文件系统类型) sudo df –l(显示硬盘挂载情况)sudo mount –t ext4 /dev/sdb(想要挂载的硬盘) /devdata(目标挂载点)结束后可以用sudo df –l 查看是否成功 配置系统启动自动挂载，修改/etc/fstab文件，添加/devdata was on /dev/sdbUUID=37eaa526-5d96-4237-8468-603df5216ce9 /devdata(挂载点) ext4 defaults 0 2硬盘的UUID通过命令 sudo blkid 进行查看 这样就把/dev/sdb挂载到/devdata这个文件夹下了。有人要问了，我不要挂这里，要把硬盘挂到/home目录下怎么办？接下来就是解决这个问题 首先要做的是卸载原先的挂载点，怎么做，很简单， sudo umount /dev/sdb(这里好像是写挂载的文件夹名也可以，但我没有试过)，再用 sudo df -l 查看，原先挂载的硬盘就没有了。 接下来你得挂载已经分区好的硬盘，然后把 home 目录下的全部文件拷贝到硬盘挂载的目录下。然后删除 home 目录，最后把第一步挂载好的新硬盘重新挂载在 home 目录下。 挂载设置好的硬盘 同步 home 目录所有文件，删除之前的 home 目录下的所有文件 确定同步成功之后，删除旧 home 目录 重新挂载新硬盘并设置启动挂载 这里如果失败的话就修改/etc/fstab文件，把原先的挂载点改成/home再 sudo df -l，就可以看到成功挂载到/home下了，不过这样对新机器是没什么影响，如果原先机器上有非root用户，这样操作后就GG了，还是要做好数据备份]]></content>
      <tags>
        <tag>手把手教你配置Ubuntu server服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu server 16.04 安装教程------by邵碧尧]]></title>
    <url>%2F2017%2F07%2F23%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%85%8D%E7%BD%AEUbuntu%20server%E6%9C%8D%E5%8A%A1%E5%99%A8_1%2F</url>
    <content type="text"><![CDATA[手把手教你配置Ubuntu server服务器近期实验室来了台新的服务器，第一次从头到尾把配置过程走了一遍，特来此总结一番，希望可以帮助到想入坑的童鞋。我将从以下几个方面来总结配置服务器的过程(系统版本为Ubuntu server 16.04) Ubuntu server 16.04 安装教程 服务器多硬盘挂载 设置服务器网络 管理服务器用户 安装远程图形界面x2go Ubuntu server 16.04 安装教程 Ubuntu server 16.04 启动U盘制作用装系统，没启用U盘怎么行呢！Ubuntu系统的启动U盘制作非常简单，首先从官网下载对应版本的系统镜像文件，下一步你需要一个空白的U盘，用于写入镜像文件，如果U盘中有资料千万做好备份。写入镜像文件的软件可以使用软碟通。 用软碟通打开镜像文件 菜单中“启动”-&gt;“写入硬盘映像” 写入U盘中，点击“写入”，然后就可以吃着火锅唱着歌等着进度条跑完就好了 安装Ubuntu serverMarkdown Extra 表格语法：首先用U盘启动，之前需要查下主板进入boot menu的快捷键（一般是Esc，Del，F2，F12等），选择自己U盘启动（可能会有一个UEFI选项，两者都行） 2017.7.12 update: 推荐大家安装时都选择英文版本，有时候选择中文版在最后安装的时候会报一些没办法解决的错误 用启动盘成功引导之后，出现下面的界面，恭喜你完成了第一步 选择语言你喜欢什么语言就什么语言咯 选择是否继续安装所选择的语言版本，选择”yes 选择”否”，默认键盘模式就好了 然后等进度条跑完，到这里键盘就已经好了，下面来配置服务器的一些基本信息。主机名自己起，但只能用字母和数字 激动人心的时候到了，设置服务器的第一个用户，没错，就是你啦 设置密码 要不要加密主目录，先“否”吧 设置时区，还是默认 接下来就是最关键的，选择系统安装硬盘，作者小白就不用“手动”了 这里选择空白区（理想情况就是系统装在固态中，然后再挂载一个大的机械硬盘） 这里我是选了一块空白的固态，大小是“max” 分区设定结束并将修改写入磁盘，结束后出现下面窗口 用空格选择：OpenSSH server 选择“yes” “continue”重启，完工 网络什么的安装过程不配置都没有问题，系统装好了再解决，放心大胆搞，最坏就是重装嘛，硬件一般不会搞坏。今天先写到这里，后面我接着按照前面的大纲更新，其实网上这些东西都有，我就是帮大家归纳总结下，希望对大家有帮助吧]]></content>
      <tags>
        <tag>手把手教你配置Ubuntu server服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu密钥登录教程]]></title>
    <url>%2F2017%2F07%2F22%2Fubuntu%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ubuntu密钥登录教程上文已经讲诉了ubuntu系统设置密匙登陆，接下来讲解一下如何登陆。本文使用XShell进行远程连接使用WinSCP来进行ubuntu与ubuntu之间的文件的传输 XShell首先现在登录时输入密码那一栏已经变成了灰色，这个时候只能使用密匙登录了。拿到密钥的第一步可以先添加密钥 找到自己密钥的路径即可 密钥导入进来以后那个文件就可以不要了，当然如果还有其他地方需要的话还需要导入其他的地方，不过如果误删了不要方，旁边还有导出呢。导入成功以后可以进入属性 大家可以更改密码，初始密码都为空的，这个地方相当于你再给你的密钥又手动加了一层密码，当然也可以不加，因为我发现加了以后登录的时候还要你自己输入一遍。属性上面还有一公钥，这个里面就是我们放到服务器中的东西，这个东西不要给别人，当然我给你们的密匙你们更不能给别人，否者别人就可以轻松的登录你的账号了。剩下的登录方法更以前一样。 WinSCP同样此时winscp用密码也登录不上了确认 直接在之前建立的那个里面更改就好，点击编辑然后点高级 验证 然后添加密钥文件的路径 右下角选择所有文件 选择密匙然后有一个格式转换，选择确定 然后保存确定保存就完了，大功告成可以链接了。]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 系统设置密钥登陆]]></title>
    <url>%2F2017%2F07%2F22%2FUbuntu%20%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E5%AF%86%E9%92%A5%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[Ubuntu 系统设置密钥登陆本文主要参考文档 http://www.downgle.com/zt/zqxouw0qwvstzrouysrloolz.html http://blog.csdn.net/kenhins/article/details/51585565自己简单整理留作备份以备后期查看个人感觉用密钥登陆比用密码登陆安全很多，所以一旦生成密码之后一定不要将自己的密钥给别人，否者别人将很轻松的登陆你的账户，当然我发现如果你使用XShell远程连接ubuntu服务器的时候你可以再给密钥加上一层密码的。 密钥的生成这一步如果你使用XShell的话其实很简单，在上面的工具中有一个“新建用户密钥生成向导”，进去你自己一定会的，这里就不多说了 设置密钥登陆首先需要修改一些配置文件 vim /etc/ssh/sshd_config 进入sshd_config文件后需要更改几个地方 PubkeyAuthentication yes #启用公告密钥配对认证方式 AuthorizedKeysFile %h/.ssh/authorized_keys #设定PublicKey文件路径 RSAAuthentication yes #允许RSA密钥 PasswordAuthentication no #禁止密码验证登录,如果启用的话,RSA认证登录就没有意义了 #禁用root账户登录，非必要，但为了安全性，请配置 PermitRootLogin no 其实我在配置的时候发现其中有些找了很多遍都没有找到，然后我就直接手动照着输入一遍也是可以的。 然后保存配置，重新启动服务 service sshd restart 配置密钥由上面的配置文件我们可以看出来密钥放置的位置应该在用户根目录下的.ssh/authorized_keys中，如果系统本身就有authorize_keys，那么你就可以直接将你的公钥复制进来但是一般情况下刚装好的新机器没有这个目录，这就需要我们先生成一个(这里我们可以直接进入你要创建的账户去进行，可以使用指令 su 需要创建的用户名) ssh-keygen 输入该指令后一路回车即可回头用指令 ll 你可以发现在当前用户的更目录下就会生成一个 .ssh的文件夹,然后再进入这个文件夹操作 cd ~/.ssh vim authorized_keys 把自己生成的公钥复制进来就可以了然后保存，并且更改文件模式 chmod 600 authorized_keys 注意：有些时候复制的时候可能不全，尤其前面缺少几个字母，这个需要自己检查一下，否则登陆会不成功的]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双系统时ubuntu更改开机引导]]></title>
    <url>%2F2017%2F07%2F22%2F%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6ubuntu%E6%9B%B4%E6%94%B9%E5%BC%80%E6%9C%BA%E5%BC%95%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[我们在windows上安装ubuntu双系统的时候，ubuntu的引导会默认先进入ubuntu系统，这对于那些想使用ubuntu但是并不常用ubuntu系统的人有一些不方便。在网上我有看到EaseBCD这个软件可以用来管理启动项的。但是因为个人之前和身边的朋友使用过，感觉其实并没有解决用户的问题，不安装EaseBCD的时候只用进入一次选择界面，而安装完EaseBCD的时候我们竟然需要进入两次引导界面，这就很不方便。（此处之争对ubuntu其他的双系统也许EaseBCD会更加方便些）另外之前一个朋友发现这个地方很不方便，于是就卸载了EaseBCD结果他的系统完全进不去了，最后在大神的指导下才修复进入了windows系统。说了这么多到底如何更改启动项呢？其实使用ubuntu自带的系统文件就可以了。 根据ubuntu自带的系统文件就可以修改启动顺序进入系统文件 sudo vim /etc/default/grub 进去之后找到GRUB_DEFAULT，它代表启动顺序。然后后面的数字需要根据自己电脑开机时显示的顺序进行选择当然里面还有很多的文件，还可以修改其他的参数，比如，选择界面等待的时间等（默认是10s,如果觉得开机时间太久了，可以自行更改的）]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu环境下降低gcc和g++的版本]]></title>
    <url>%2F2017%2F07%2F22%2Fubuntu-Reduce-the-version-gcc-g%2B%2B%2F</url>
    <content type="text"><![CDATA[有时候我们在跑别人的程序的时候发现自己编译器的版本过高以至于不能运行，这个时候我们就需要降低编译器的版本。 首先安装低版本的编译器这里由于本人用的ubuntu16.04所以编译器自带的是gcc-5.4和g++-5.4,但是需要低版本的，经过测试现在还可以安装4.7的版本 sudo apt-get install gcc-4.7 gcc-4.7-multilib g++-4.7 g++-4.7-multilib 配置级别sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.7 50 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 40 接着输入 sudo update-alternatives --config gcc 然后可以自己选择版本。 同理配置好了gcc还要配置g++ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.7 50 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 40 同理g++的选择为： sudo update-alternatives --config g++ 如果想删除可选项的话可以键入以下指令： sudo update-alternatives --remove gcc /usr/bin/gcc-4.5 本文是自己跟同门根据网上资料整理而得，希望对大家有用。]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu16.04 Server install CUDA]]></title>
    <url>%2F2017%2F07%2F22%2Fubuntu16-04-Server-install-CUDA%2F</url>
    <content type="text"><![CDATA[ubuntu16.04 Server 安装CUDA在安装CUDA的时候经常会遇到CUDA安装失败的情况，一般遇到的不允许第三方软件的安装，或者是自带的驱动nouveau的存在。 允许第三方软件的安装这个需要自己重启电脑进入bios系统中去关闭UEFI的安全启动/安全引导 关闭自带的驱动nouveausudo vim /etc/modprobe.d/blacklist.conf 在该文件中添加以下几行： blacklist vga16fb blacklist rivafb blacklist rivatv blacklist nvidiafb options nouveau modeset=0 添加完以后保存该文件接着更新该文件，使配置有用 sudo update-initramfs -u 最后查看nouveau驱动禁止是否成功，如果没有内容则说明禁用成功。 如果nouveau驱动禁用后没有效果，可以进行强制移除该驱动（如果上面的方法禁用成功可以不使用该方法）将这个驱动备份出来然后移除 mv /lib/modules/3.0.0-12-generic/kernel/drivers/gpu/drm/nouveau/nouveau.ko /lib/modules/3.0.0-12-generic/kernel/drivers/gpu/drm/nouveau/nouveau.ko.org 重新加载 update-initramfs -u 重启发现字体已经变大了，卸载成功。 CUDA的安装因为本文说的ubuntu Server所以安装完一般使没有图形界面的，所以不需要去禁用图形界面，如果不是server版本的话一般还需要禁用图形界面的（可以用ctrl+alt+F1进入文本界面，F1~F6都可以F7是退出文本界面）。禁用图形界面的语句： sudo service lightdm stop 打开图形界面的语句： sudo service lightdm start nouveau禁用成功了，bios中的UEFI也已经关了，这个时候就可以安心的装CUDA了。首先需要安装依赖项： sudo apt-get install build-essential pkg-config linux-headers-$(uname -r) 或者下面的方法也可以（用了上面的语句下面的语句就不需要了）： sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler sudo apt-get install --no-install-recommends libboost-all-dev sudo apt-get install libopenblas-dev liblapack-dev libatlas-base-dev sudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-dev 下载CUDA的安装包https://developer.nvidia.com/cuda-downloads可以去NVIDIA的官网去下载，可以根据需求下载。本文下载的runfile，其他形式的文本运行方法在下载界面有介绍的。下载好后用U盘或者SCP等上传到服务器上，接下来进入cuda安装包的地方执行，当然这里根据你的安装包的型号。 sudo sh cuda_8.0.61_375.26_linux.run 执行以后会有一堆文本让你读，很多，不过可以直接按q退出，然后按照要求先accept，然后再按照自己的需求安装，因为上面没有手动安装过nvidia的驱动，所以这里需要选择安装驱动的，否则cuda即使安装上了也没有用的。选择完了就开始安装了，安装完成后会有一个Summary显示安装的情况的。到此基本安装完了，可以使用下面的语句去检测nvidia驱动是否安装成功： cat /proc/driver/nvidia/version 如果可以弹出来驱动的版本信息等，说明安装成功，否者没有安装成功。 安装完后此时查找cuda是找不到的，因为还没有配置环境变量。接下来配置环境变量： echo &#39;export PATH=/usr/local/cuda/bin:$PATH&#39; &gt;&gt; ~/.bashrc echo &#39;export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH&#39; &gt;&gt; ~/.bashrc source ~/.bashrc 配置完环境变量后再检查一下cuda是否安装成功 nvcc -V 提示上面的必须是大写的V，小写的v是不能够被识别的。 如果要卸载或者重装卸载或者重新安装了。这个时候需要先卸载之前安装的。这个在用run文件安装的时候，最后那个summary已经告诉我们如何卸载了。 To uninstall the CUDA Toolkit. run the uninstall scrip in /usr/local/cuda-8.0/bin To uninstall the NVIDIA Driver. run nvidia-unistall 可以先按照上面的提示去卸载CUDA和NVIDIA驱动，当然还有其他的方法 sudo apt-get --purge remove &lt;package_name&gt; 本文参考网络上各种资源自己配置完自己实验室电脑后整理所得，做一个备忘所用，当然也希望对大家有用。]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thanks]]></title>
    <url>%2F2017%2F07%2F22%2Fthanks%2F</url>
    <content type="text"><![CDATA[Thanks for JingJing’s help to me!]]></content>
      <tags>
        <tag>start</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>start</tag>
      </tags>
  </entry>
</search>
